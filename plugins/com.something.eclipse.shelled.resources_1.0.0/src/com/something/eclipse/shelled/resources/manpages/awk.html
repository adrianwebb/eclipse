<HTML>
<BODY>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->

</PRE>
<H2>SYNOPSIS</H2><PRE>
       <B>gawk</B> [ POSIX or GNU style options ] <B>-f</B> <I>program-file</I> [ <B>--</B> ]
       file ...
       <B>gawk</B> [ POSIX or GNU style options ] [  <B>--</B>  ]  <I>program-text</I>
       file ...

       <B>pgawk</B>  [ POSIX or GNU style options ] <B>-f</B> <I>program-file</I> [ <B>--</B>
       ] file ...
       <B>pgawk</B> [ POSIX or GNU style options ] [ <B>--</B>  ]  <I>program-text</I>
       file ...


</PRE>
<H2>DESCRIPTION</H2><PRE>
       <I>Gawk</I>  is  the GNU Project's implementation of the AWK pro­
       gramming language.  It conforms to the definition  of  the
       language  in  the POSIX 1003.2 Command Language And Utili­
       ties Standard.  This version  in  turn  is  based  on  the
       description  in  <I>The</I>  <I>AWK</I>  <I>Programming</I>  <I>Language</I>,  by Aho,
       Kernighan, and Weinberger, with  the  additional  features
       found in the System V Release 4 version of UNIX <I>awk</I>.  <I>Gawk</I>
       also provides more recent  Bell  Laboratories  <I>awk</I>  exten­
       sions, and a number of GNU-specific extensions.

       <I>Pgawk</I>  is  the profiling version of <I>gawk</I>.  It is identical
       in every way  to  <I>gawk</I>,  except  that  programs  run  more
       slowly, and it automatically produces an execution profile
       in the file <B>awkprof.out</B>  when  done.   See  the  <B>--profile</B>
       option, below.

       The  command  line consists of options to <I>gawk</I> itself, the
       AWK program text (if not supplied via  the  <B>-f</B>  or  <B>--file</B>
       options),  and values to be made available in the <B>ARGC</B> and
       <B>ARGV</B> pre-defined AWK variables.


</PRE>
<H2>OPTION FORMAT</H2><PRE>
       <I>Gawk</I> options may be either traditional  POSIX  one  letter
       options,  or  GNU style long options.  POSIX options start
       with a single "-", while long  options  start  with  "--".
       Long  options  are provided for both GNU-specific features
       and for POSIX-mandated features.

       Following the POSIX standard,  <I>gawk</I>-specific  options  are
       supplied  via  arguments  to  the  <B>-W</B> option.  Multiple <B>-W</B>
       options may be supplied Each <B>-W</B> option has a corresponding
       long option, as detailed below.  Arguments to long options
       are either joined with the option by an <B>=</B>  sign,  with  no
       intervening  spaces,  or  they may be provided in the next
       command line argument.  Long options may  be  abbreviated,
       as long as the abbreviation remains unique.


</PRE>
<H2>OPTIONS</H2><PRE>
       <I>Gawk</I> accepts the following options, listed alphabetically.

              Read the AWK program source from the file  <I>program-</I>
              <I>file</I>,  instead of from the first command line argu­
              ment.  Multiple <B>-f</B> (or <B>--file</B>) options may be used.

       <B>-mf</B> <I>NNN</I>
       <B>-mr</B> <I>NNN</I>
              Set  various memory limits to the value <I>NNN</I>.  The <B>f</B>
              flag sets the maximum number of fields, and  the  <B>r</B>
              flag sets the maximum record size.  These two flags
              and the <B>-m</B> option are from  the  Bell  Laboratories
              research  version of UNIX <I>awk</I>.  They are ignored by
              <I>gawk</I>, since <I>gawk</I> has no pre-defined limits.

       <B>-W</B> <B>compat</B>
       <B>-W</B> <B>traditional</B>
       <B>--compat</B>
       <B>--traditional</B>
              Run in <I>compatibility</I> mode.  In compatibility  mode,
              <I>gawk</I>  behaves  identically to UNIX <I>awk</I>; none of the
              GNU-specific extensions are recognized.  The use of
              <B>--traditional</B>  is preferred over the other forms of
              this option.  See <B>GNU</B> <B>EXTENSIONS</B>, below,  for  more
              information.

       <B>-W</B> <B>copyleft</B>
       <B>-W</B> <B>copyright</B>
       <B>--copyleft</B>
       <B>--copyright</B>
              Print the short version of the GNU copyright infor­
              mation message on the standard output and exit suc­
              cessfully.

       <B>-W</B> <B>dump-variables</B>[<B>=</B><I>file</I>]
       <B>--dump-variables</B>[<B>=</B><I>file</I>]
              Print  a  sorted  list  of  global variables, their
              types and final values to <I>file</I>.  If no <I>file</I> is pro­
              vided,  <I>gawk</I>  uses  a file named <I>awkvars.out</I> in the
              current directory.
              Having a list of all the global variables is a good
              way  to  look for typographical errors in your pro­
              grams.  You would also use this option if you  have
              a  large  program  with a lot of functions, and you
              want to be sure that your functions don't  inadver­
              tently  use  global  variables that you meant to be
              local.  (This is a  particularly  easy  mistake  to
              make  with  simple variable names like <B>i</B>, <B>j</B>, and so
              on.)

       <B>-W</B> <B>help</B>
       <B>-W</B> <B>usage</B>
       <B>--help</B>
       <B>--usage</B>
       <B>-W</B> <B>lint-old</B>
       <B>--lint-old</B>
              Provide warnings  about  constructs  that  are  not
              portable to the original version of Unix <I>awk</I>.

       <B>-W</B> <B>gen-po</B>
       <B>--gen-po</B>
              Scan  and parse the AWK program, and generate a GNU
              <B>.po</B> format file on standard output with entries for
              all  localizable  strings in the program.  The pro­
              gram itself is not executed.  See the  GNU  <I>gettext</I>
              distribution for more information on <B>.po</B> files.

       <B>-W</B> <B>non-decimal-data</B>
       <B>--non-decimal-data</B>
              Recognize  octal  and  hexadecimal  values in input
              data.  <I>Use</I> <I>this</I> <I>option</I> <I>with</I> <I>great</I> <I>caution!</I>

       <B>-W</B> <B>posix</B>
       <B>--posix</B>
              This turns on <I>compatibility</I> mode, with the  follow­
              ing additional restrictions:

              · <B>\x</B> escape sequences are not recognized.

              · Only  space  and tab act as field separators when
                <B>FS</B> is set to a single space, newline does not.

              · You cannot continue lines after <B>?</B>  and <B>:</B>.

              · The synonym <B>func</B> for the keyword <B>function</B> is  not
                recognized.

              · The  operators <B>**</B> and <B>**=</B> cannot be used in place
                of <B>^</B> and <B>^=</B>.

              · The <B>fflush()</B> function is not available.

       <B>-W</B> <B>profile</B>[<B>=</B><I>prof</I><B>_</B><I>file</I>]
       <B>--profile</B>[<B>=</B><I>prof</I><B>_</B><I>file</I>]
              Send profiling data to <I>prof</I><B>_</B><I>file</I>.  The  default  is
              <B>awkprof.out</B>.   When  run  with <I>gawk</I>, the profile is
              just a "pretty printed"  version  of  the  program.
              When run with <I>pgawk</I>, the profile contains execution
              counts of each statement in the program in the left
              margin  and  function  call  counts  for each user-
              defined function.

       <B>-W</B> <B>re-interval</B>
       <B>--re-interval</B>
              Enable the use of <I>interval</I> <I>expressions</I>  in  regular
              expression   matching   (see  <B>Regular</B>  <B>Expressions</B>,
              intended primarily for medium to large AWK programs
              used in shell scripts.

       <B>-W</B> <B>version</B>
       <B>--version</B>
              Print  version information for this particular copy
              of <I>gawk</I> on the standard  output.   This  is  useful
              mainly  for  knowing if the current copy of <I>gawk</I> on
              your system is up to date with respect to  whatever
              the Free Software Foundation is distributing.  This
              is also useful when reporting bugs.  (Per  the  <I>GNU</I>
              <I>Coding</I> <I>Standards</I>, these options cause an immediate,
              successful exit.)

       <B>--</B>     Signal the end of options. This is useful to  allow
              further  arguments  to  the  AWK  program itself to
              start with a "-".  This is mainly  for  consistency
              with  the  argument parsing convention used by most
              other POSIX programs.
       In compatibility mode, any other options  are  flagged  as
       invalid,  but are otherwise ignored.  In normal operation,
       as long as program text has been supplied, unknown options
       are  passed  on  to  the AWK program in the <B>ARGV</B> array for
       processing.  This is particularly useful for  running  AWK
       programs via the "#!" executable interpreter mechanism.

</PRE>
<H2>AWK PROGRAM EXECUTION</H2><PRE>
       An  AWK  program  consists of a sequence of pattern-action
       statements and optional function definitions.
              <I>pattern</I>   <B>{</B> <I>action</I> <I>statements</I> <B>}</B>
              <B>function</B> <I>name</I><B>(</B><I>parameter</I> <I>list</I><B>)</B> <B>{</B> <I>statements</I> <B>}</B>
       <I>Gawk</I> first reads the  program  source  from  the  <I>program-</I>
       <I>file</I>(s)  if specified, from arguments to <B>--source</B>, or from
       the first non-option argument on the command line.  The <B>-f</B>
       and  <B>--source</B>  options  may  be used multiple times on the
       command line.  <I>Gawk</I> reads the program text as if  all  the
       <I>program-file</I>s  and command line source texts had been con­
       catenated together.  This is useful for building libraries
       of  AWK  functions, without having to include them in each
       new AWK program that uses  them.   It  also  provides  the
       ability  to  mix  library functions with command line pro­
       grams.
       The environment variable <B>AWKPATH</B> specifies a  search  path
       to use when finding source files named with the <B>-f</B> option.
       If this variable does  not  exist,  the  default  path  is
       <B>".:/usr/local/share/awk"</B>.  (The actual directory may vary,
       depending upon how <I>gawk</I> was built and  installed.)   If  a
       file name given to the <B>-f</B> option contains a "/" character,
       no path search is performed.
       <I>Gawk</I> executes AWK programs in the following order.  First,
       all  variable  assignments specified via the <B>-v</B> option are
       performed.  Next, <I>gawk</I> compiles the program into an inter­
       nal  form.   Then,  <I>gawk</I>  executes  the  code in the <B>BEGIN</B>
       For  each  record  in  the  input, <I>gawk</I> tests to see if it
       matches any <I>pattern</I> in the AWK program.  For each  pattern
       that  the  record  matches,  the associated <I>action</I> is exe­
       cuted.  The patterns are tested in the order they occur in
       the program.
       Finally,  after  all the input is exhausted, <I>gawk</I> executes
       the code in the <B>END</B> block(s) (if any).

</PRE>
<H2>VARIABLES, RECORDS AND FIELDS</H2><PRE>
       AWK variables are dynamic; they come into  existence  when
       they  are  first  used.  Their values are either floating-
       point numbers or strings, or both, depending upon how they
       are  used.   AWK  also  has one dimensional arrays; arrays
       with multiple dimensions may be simulated.   Several  pre-
       defined variables are set as a program runs; these will be
       described as needed and summarized below.
   <B>Records</B>
       Normally, records are  separated  by  newline  characters.
       You  can  control  how  records are separated by assigning
       values to the built-in variable <B>RS</B>.  If <B>RS</B> is  any  single
       character,  that  character separates records.  Otherwise,
       <B>RS</B> is a  regular  expression.   Text  in  the  input  that
       matches  this  regular  expression  separates  the record.
       However, in compatibility mode, only the  first  character
       of its string value is used for separating records.  If <B>RS</B>
       is set to the null string, then records are  separated  by
       blank  lines.  When <B>RS</B> is set to the null string, the new­
       line character always acts as a field separator, in  addi­
       tion to whatever value <B>FS</B> may have.
   <B>Fields</B>
       As  each input record is read, <I>gawk</I> splits the record into
       <I>fields</I>, using the value of the <B>FS</B> variable  as  the  field
       separator.   If <B>FS</B> is a single character, fields are sepa­
       rated by that character.  If <B>FS</B> is the null  string,  then
       each  individual character becomes a separate field.  Oth­
       erwise, <B>FS</B> is expected to be a  full  regular  expression.
       In  the special case that <B>FS</B> is a single space, fields are
       separated by runs of spaces and/or tabs  and/or  newlines.
       (But  see  the  discussion  of <B>--posix</B>, below).  <B>NOTE:</B> The
       value of <B>IGNORECASE</B> (see below) also  affects  how  fields
       are split when <B>FS</B> is a regular expression, and how records
       are separated when <B>RS</B> is a regular expression.
       If the <B>FIELDWIDTHS</B> variable is set to  a  space  separated
       list  of  numbers,  each  field  is expected to have fixed
       width, and <I>gawk</I> splits up the record using  the  specified
       widths.   The  value  of  <B>FS</B>  is ignored.  Assigning a new
       value to <B>FS</B> overrides the use of <B>FIELDWIDTHS</B>, and restores
       the default behavior.
       Each  field  in  the input record may be referenced by its
       position, <B>$1</B>, <B>$2</B>, and so on.   <B>$0</B>  is  the  whole  record.
       Fields need not be referenced by constants:
              <B>n</B> <B>=</B> <B>5</B>
              <B>print</B> <B>$n</B>

       record to be rebuilt when <B>$0</B>  is  referenced.   Similarly,
       assigning  a  value to <B>$0</B> causes the record to be resplit,
       creating new values for the fields.
   <B>Built-in</B> <B>Variables</B>
       <I>Gawk</I>'s built-in variables are:
       <B>ARGC</B>        The number of command line arguments (does not
                   include   options  to  <I>gawk</I>,  or  the  program
                   source).
       <B>ARGIND</B>      The index in <B>ARGV</B> of the  current  file  being
                   processed.
       <B>ARGV</B>        Array of command line arguments.  The array is
                   indexed from  0  to  <B>ARGC</B>  -  1.   Dynamically
                   changing  the contents of <B>ARGV</B> can control the
                   files used for data.
       <B>BINMODE</B>     On  non-POSIX  systems,   specifies   use   of
                   "binary"  mode for all file I/O.  Numeric val­
                   ues of 1, 2, or 3, specify that  input  files,
                   output  files,  or  all  files,  respectively,
                   should use binary I/O.  String values of  <B>"r"</B>,
                   or  <B>"w"</B>  specify  that  input files, or output
                   files, respectively, should  use  binary  I/O.
                   String values of <B>"rw"</B> or <B>"wr"</B> specify that all
                   files should use binary I/O.  Any other string
                   value  is  treated  as  <B>"rw"</B>,  but generates a
                   warning message.
       <B>CONVFMT</B>     The conversion format for numbers, <B>"%.6g"</B>,  by
                   default.
       <B>ENVIRON</B>     An  array containing the values of the current
                   environment.  The  array  is  indexed  by  the
                   environment  variables, each element being the
                   value of that variable (e.g.,  <B>ENVIRON["HOME"]</B>
                   might  be  <B>/home/arnold</B>).  Changing this array
                   does not affect the environment seen  by  pro­
                   grams which <I>gawk</I> spawns via redirection or the
                   <B>system()</B> function.
       <B>ERRNO</B>       If a system error occurs either doing a  redi­
                   rection  for  <B>getline</B>,  during a read for <B>get­</B>
                   <B>line</B>, or during a  <B>close()</B>,  then  <B>ERRNO</B>  will
                   contain  a  string  describing the error.  The
                   value is subject to translation in non-English
                   locales.
       <B>FIELDWIDTHS</B> A  white-space  separated list of fieldwidths.
                   When set, <I>gawk</I> parses the input into fields of
                   fixed width, instead of using the value of the
                   <B>FS</B> variable as the field separator.
       <B>FILENAME</B>    The name of the current  input  file.   If  no
                   files  are  specified on the command line, the
                   value of <B>FILENAME</B> is "-".   However,  <B>FILENAME</B>
                   is  undefined  inside  the <B>BEGIN</B> block (unless
                   set by <B>getline</B>).
       <B>FNR</B>         The input record number in the  current  input
                   file.
                   matches  all  of the strings <B>"ab"</B>, <B>"aB"</B>, <B>"Ab"</B>,
                   and <B>"AB"</B>.  As with all AWK variables, the ini­
                   tial value of <B>IGNORECASE</B> is zero, so all regu­
                   lar expression and string operations are  nor­
                   mally  case-sensitive.   Under  Unix, the full
                   ISO 8859-1 Latin-1 character set is used  when
                   ignoring case.
       <B>LINT</B>        Provides  dynamic control of the <B>--lint</B> option
                   from within an AWK program.  When  true,  <I>gawk</I>
                   prints lint warnings. When false, it does not.
                   When assigned the string value  <B>"fatal"</B>,  lint
                   warnings  become  fatal  errors,  exactly like
                   <B>--lint=fatal</B>.   Any  other  true  value   just
                   prints warnings.
       <B>NF</B>          The  number  of  fields  in  the current input
                   record.
       <B>NR</B>          The total number of input records seen so far.
       <B>OFMT</B>        The  output  format  for  numbers,  <B>"%.6g"</B>, by
                   default.
       <B>OFS</B>         The  output  field  separator,  a   space   by
                   default.
       <B>ORS</B>         The output record separator, by default a new­
                   line.
       <B>PROCINFO</B>    The elements of this array provide  access  to
                   information about the running AWK program.  On
                   some systems, there may  be  elements  in  the
                   array,  <B>"group1"</B>  through <B>"group</B><I>n</I><B>"</B> for some <I>n</I>,
                   which is the number  of  supplementary  groups
                   that  the process has.  Use the <B>in</B> operator to
                   test for these elements.  The  following  ele­
                   ments are guaranteed to be available:
                   <B>PROCINFO["egid"]</B>   the value of the <B>getegid(2)</B>
                                      system call.
                   <B>PROCINFO["euid"]</B>   the value of the <B>geteuid(2)</B>
                                      system call.
                   <B>PROCINFO["FS"]</B>     <B>"FS"</B>   if  field  splitting
                                      with <B>FS</B> is  in  effect,  or
                                      <B>"FIELDWIDTHS"</B>    if   field
                                      splitting with  <B>FIELDWIDTHS</B>
                                      is in effect.
                   <B>PROCINFO["gid"]</B>    the  value of the <B>getgid(2)</B>
                                      system call.
                   <B>PROCINFO["pgrpid"]</B> the process group ID of the
                                      current process.
                   <B>PROCINFO["pid"]</B>    the  process ID of the cur­
                                      rent process.
                   <B>PROCINFO["ppid"]</B>   the parent  process  ID  of
                                      the current process.
                   <B>PROCINFO["uid"]</B>    the  value of the <B>getuid(2)</B>
                                      system call.
       <B>RS</B>          The input record separator, by default a  new­
                   line.

       Arrays are subscripted with an expression  between  square
       brackets  (<B>[</B>  and  <B>]</B>).  If the expression is an expression
       list (<I>expr</I>, <I>expr</I> ...)   then  the  array  subscript  is  a
       string  consisting  of  the  concatenation of the (string)
       value of each expression, separated by the  value  of  the
       <B>SUBSEP</B> variable.  This facility is used to simulate multi­
       ply dimensioned arrays.  For example:
              <B>i</B> <B>=</B> <B>"A";</B> <B>j</B> <B>=</B> <B>"B";</B> <B>k</B> <B>=</B> <B>"C"</B>
              <B>x[i,</B> <B>j,</B> <B>k]</B> <B>=</B> <B>"hello,</B> <B>world\n"</B>
       assigns the string <B>"hello,</B> <B>world\n"</B> to the element of  the
       array <B>x</B> which is indexed by the string <B>"A\034B\034C"</B>.  All
       arrays in AWK are associative, i.e. indexed by string val­
       ues.
       The  special  operator  <B>in</B>  may  be used in an <B>if</B> or <B>while</B>
       statement to see if an array has an index consisting of  a
       particular value.
              <B>if</B> <B>(val</B> <B>in</B> <B>array)</B>
                   <B>print</B> <B>array[val]</B>
       If the array has multiple subscripts, use <B>(i,</B> <B>j)</B> <B>in</B> <B>array</B>.
       The <B>in</B> construct may also be used in a <B>for</B> loop to iterate
       over all the elements of an array.
       An  element  may be deleted from an array using the <B>delete</B>
       statement.  The <B>delete</B>  statement  may  also  be  used  to
       delete the entire contents of an array, just by specifying
       the array name without a subscript.
   <B>Variable</B> <B>Typing</B> <B>And</B> <B>Conversion</B>
       Variables and fields may be (floating point)  numbers,  or
       strings,  or  both.  How the value of a variable is inter­
       preted depends upon its context.  If  used  in  a  numeric
       expression,  it  will be treated as a number, if used as a
       string it will be treated as a string.
       To force a variable to be treated as a number,  add  0  to
       it;  to force it to be treated as a string, concatenate it
       with the null string.
       When a string must be converted to a number,  the  conver­
       sion  is  accomplished  using <B>strtod(3)</B>.  A number is con­
       verted to a string by using the value of <B>CONVFMT</B> as a for­
       mat  string  for <B>sprintf(3)</B>, with the numeric value of the
       variable as the argument.  However, even though  all  num­
       bers in AWK are floating-point, integral values are <I>always</I>
       converted as integers.  Thus, given
              <B>CONVFMT</B> <B>=</B> <B>"%2.2f"</B>
              <B>a</B> <B>=</B> <B>12</B>
              <B>b</B> <B>=</B> <B>a</B> <B>""</B>
       the variable <B>b</B> has a string value of <B>"12"</B> and not <B>"12.00"</B>.
       <I>Gawk</I> performs comparisons as follows: If two variables are
       numeric, they are compared numerically.  If one  value  is
       numeric  and  the  other  has  a  string  value  that is a
       "numeric string," then comparisons are also  done  numeri­
       cally.   Otherwise,  the  numeric  value is converted to a
       string and a string comparison is performed.  Two  strings
       are  compared, of course, as strings.  Note that the POSIX
       Starting with version 3.1 of <I>gawk</I> <I>,</I> you  may  use  C-style
       octal and hexadecimal constants in your AWK program source
       code.  For example, the octal value <B>011</B> is equal to  deci­
       mal  <B>9</B>, and the hexadecimal value <B>0x11</B> is equal to decimal
       17.
   <B>String</B> <B>Constants</B>
       String  constants  in  AWK  are  sequences  of  characters
       enclosed  between double quotes (<B>"</B>).  Within strings, cer­
       tain <I>escape</I> <I>sequences</I> are recognized, as in C.  These are:
       <B>\\</B>   A literal backslash.
       <B>\a</B>   The  "alert" character; usually the ASCII BEL charac­
            ter.
       <B>\b</B>   backspace.
       <B>\f</B>   form-feed.
       <B>\n</B>   newline.
       <B>\r</B>   carriage return.
       <B>\t</B>   horizontal tab.
       <B>\v</B>   vertical tab.
       <B>\x</B><I>hex</I> <I>digits</I>
            The character represented by the string of  hexadeci­
            mal  digits following the <B>\x</B>.  As in ANSI C, all fol­
            lowing hexadecimal digits are considered part of  the
            escape  sequence.  (This feature should tell us some­
            thing about language  design  by  committee.)   E.g.,
            <B>"\x1B"</B> is the ASCII ESC (escape) character.
       <B>\</B><I>ddd</I> The  character  represented by the 1-, 2-, or 3-digit
            sequence of octal digits.  E.g., <B>"\033"</B> is the  ASCII
            ESC (escape) character.
       <B>\</B><I>c</I>   The literal character <I>c</I>.
       The escape sequences may also be used inside constant reg­
       ular expressions (e.g., <B>/[</B> <B>\t\f\n\r\v]/</B> matches whitespace
       characters).
       In compatibility mode, the characters represented by octal
       and hexadecimal escape  sequences  are  treated  literally
       when  used in regular expression constants.  Thus, <B>/a\52b/</B>
       is equivalent to <B>/a\*b/</B>.

</PRE>
<H2>PATTERNS AND ACTIONS</H2><PRE>
       AWK is a line-oriented language.  The pattern comes first,
       and  then the action.  Action statements are enclosed in <B>{</B>
       and <B>}</B>.  Either the pattern may be missing, or  the  action
       may  be missing, but, of course, not both.  If the pattern
       is missing, the action is executed for every single record
       of input.  A missing action is equivalent to
              <B>{</B> <B>print</B> <B>}</B>
       which prints the entire record.
       Comments  begin with the "#" character, and continue until
       the end of the line.  Blank lines may be used to  separate
       statements.   Normally,  a  statement ends with a newline,
       however, this is not the case for lines ending in  a  ",",
       <B>{</B>,  <B>?</B>, <B>:</B>, <B>&amp;&amp;</B>, or <B>||</B>.  Lines ending in <B>do</B> or <B>else</B> also have
       their statements automatically continued on the  following
       line.   In  other cases, a line can be continued by ending
              <B>(</B><I>pattern</I><B>)</B>
              <B>!</B> <I>pattern</I>
              <I>pattern1</I><B>,</B> <I>pattern2</I>
       <B>BEGIN</B> and <B>END</B> are two special kinds of patterns which  are
       not  tested  against  the  input.  The action parts of all
       <B>BEGIN</B> patterns are merged as if  all  the  statements  had
       been  written  in a single <B>BEGIN</B> block.  They are executed
       before any of the input is read.  Similarly, all  the  <B>END</B>
       blocks  are  merged,  and  executed  when all the input is
       exhausted (or when an <B>exit</B> statement is executed).   <B>BEGIN</B>
       and <B>END</B> patterns cannot be combined with other patterns in
       pattern expressions.  <B>BEGIN</B> and <B>END</B> patterns  cannot  have
       missing action parts.
       For  <B>/</B><I>regular</I>  <I>expression</I><B>/</B> patterns, the associated state­
       ment is executed for each input record  that  matches  the
       regular  expression.   Regular expressions are the same as
       those in <B>egrep(1)</B>, and are summarized below.
       A <I>relational</I> <I>expression</I>  may  use  any  of  the  operators
       defined  below in the section on actions.  These generally
       test whether certain fields match certain regular  expres­
       sions.
       The  <B>&amp;&amp;</B>, <B>||</B>, and <B>!</B>  operators are logical AND, logical OR,
       and logical NOT, respectively, as in C.   They  do  short-
       circuit evaluation, also as in C, and are used for combin­
       ing more primitive pattern expressions.  As in  most  lan­
       guages,  parentheses  may  be  used to change the order of
       evaluation.
       The <B>?:</B> operator is like the same operator in  C.   If  the
       first pattern is true then the pattern used for testing is
       the second pattern, otherwise it is the third.   Only  one
       of the second and third patterns is evaluated.
       The  <I>pattern1</I><B>,</B>  <I>pattern2</I> form of an expression is called a
       <I>range</I> <I>pattern</I>.  It matches all input records starting with
       a  record  that  matches  <I>pattern1</I>, and continuing until a
       record that matches <I>pattern2</I>, inclusive.  It does not com­
       bine with any other sort of pattern expression.
   <B>Regular</B> <B>Expressions</B>
       Regular  expressions are the extended kind found in <I>egrep</I>.
       They are composed of characters as follows:
       <I>c</I>          matches the non-metacharacter <I>c</I>.
       <I>\c</I>         matches the literal character <I>c</I>.
       <B>.</B>          matches any character <I>including</I> newline.
       <B>^</B>          matches the beginning of a string.
       <B>$</B>          matches the end of a string.
       <B>[</B><I>abc...</I><B>]</B>   character list, matches any of  the  characters
                  <I>abc...</I>.
       <B>[^</B><I>abc...</I><B>]</B>  negated  character  list, matches any character
                  except <I>abc...</I>.
       <I>r1</I><B>|</B><I>r2</I>      alternation: matches either <I>r1</I> or <I>r2</I>.
       <I>r1r2</I>       concatenation: matches <I>r1</I>, and then <I>r2</I>.
       <I>r</I><B>+</B>         matches one or more <I>r</I>'s.
       <I>r</I><B>*</B>         matches zero or more <I>r</I>'s.

       <B>\y</B>         matches the empty string at either  the  begin­
                  ning or the end of a word.

       <B>\B</B>         matches the empty string within a word.

       <B>\&lt;</B>         matches  the empty string at the beginning of a
                  word.

       <B>\&gt;</B>         matches the empty string at the end of a  word.

       <B>\w</B>         matches any word-constituent character (letter,
                  digit, or underscore).

       <B>\W</B>         matches any character  that  is  not  word-con­
                  stituent.

       <B>\`</B>         matches  the empty string at the beginning of a
                  buffer (string).

       <B>\'</B>         matches the  empty  string  at  the  end  of  a
                  buffer.

       The  escape  sequences  that are valid in string constants
       (see below) are also valid in regular expressions.

       <I>Character</I> <I>classes</I> are a  new  feature  introduced  in  the
       POSIX  standard.   A character class is a special notation
       for describing lists of characters that  have  a  specific
       attribute,  but where the actual characters themselves can
       vary from country to country and/or from character set  to
       character  set.   For  example,  the  notion of what is an
       alphabetic character differs in the USA and in France.

       A character class is only valid in  a  regular  expression
       <I>inside</I>  the  brackets  of  a  character  list.   Character
       classes consist of <B>[:</B>, a keyword denoting the  class,  and
       <B>:]</B>.   The  character classes defined by the POSIX standard
       are:

       <B>[:alnum:]</B>  Alphanumeric characters.

       <B>[:alpha:]</B>  Alphabetic characters.

       <B>[:blank:]</B>  Space or tab characters.

       <B>[:cntrl:]</B>  Control characters.

       <B>[:digit:]</B>  Numeric characters.

       <B>[:graph:]</B>  Characters that are both printable and visible.
                  (A  space  is printable, but not visible, while

       <B>[:upper:]</B>  Upper-case alphabetic characters.

       <B>[:xdigit:]</B> Characters that are hexadecimal digits.

       For example, before the POSIX standard, to match  alphanu­
       meric   characters,   you   would   have   had   to  write
       <B>/[A-Za-z0-9]/</B>.  If your character set had other alphabetic
       characters  in  it, this would not match them, and if your
       character set collated differently from ASCII, this  might
       not  even  match  the ASCII alphanumeric characters.  With
       the POSIX character classes, you can write  <B>/[[:alnum:]]/</B>,
       and  this matches the alphabetic and numeric characters in
       your character set.

       Two additional special sequences can appear  in  character
       lists.  These apply to non-ASCII character sets, which can
       have single symbols (called <I>collating</I> <I>elements</I>)  that  are
       represented  with more than one character, as well as sev­
       eral characters that  are  equivalent  for  <I>collating</I>,  or
       sorting,  purposes.   (E.g.,  in French, a plain "e" and a
       grave-accented e` are equivalent.)

       Collating Symbols
              A collating symbol is a  multi-character  collating
              element enclosed in <B>[.</B>  and <B>.]</B>.  For example, if <B>ch</B>
              is a collating element, then <B>[[.ch.]]</B>  is a regular
              expression  that  matches  this  collating element,
              while <B>[ch]</B> is a  regular  expression  that  matches
              either <B>c</B> or <B>h</B>.

       Equivalence Classes
              An  equivalence class is a locale-specific name for
              a list of characters that are equivalent.  The name
              is  enclosed in <B>[=</B> and <B>=]</B>.  For example, the name <B>e</B>
              might be used to represent all  of  "e,"  "<B>´</B>,"  and
              "<B>`</B>."  In this case, <B>[[=e=]]</B> is a regular expression
              that matches any of <B>e</B>, <B>´</B>, or <B>`</B>.

       These features are very valuable in  non-English  speaking
       locales.  The library functions that <I>gawk</I> uses for regular
       expression matching currently only recognize POSIX charac­
       ter  classes;  they  do not recognize collating symbols or
       equivalence classes.

       The <B>\y</B>, <B>\B</B>, <B>\&lt;</B>, <B>\&gt;</B>, <B>\w</B>, <B>\W</B>, <B>\`</B>, and <B>\'</B> operators are  spe­
       cific  to <I>gawk</I>; they are extensions based on facilities in
       the GNU regular expression libraries.

       The various command line options control how  <I>gawk</I>  inter­
       prets characters in regular expressions.

       No options
              the  POSIX  character  classes  (<B>[[:alnum:]]</B> and so
              on).  Characters described by octal and hexadecimal
              escape  sequences  are  treated  literally, even if
              they represent regular expression metacharacters.

       <B>--re-interval</B>
              Allow interval expressions in regular  expressions,
              even if <B>--traditional</B> has been provided.

   <B>Actions</B>
       Action statements are enclosed in braces, <B>{</B> and <B>}</B>.  Action
       statements consist of the usual  assignment,  conditional,
       and looping statements found in most languages.  The oper­
       ators, control  statements,  and  input/output  statements
       available are patterned after those in C.

   <B>Operators</B>
       The  operators  in AWK, in order of decreasing precedence,
       are


       <B>(</B>...<B>)</B>       Grouping

       <B>$</B>           Field reference.

       <B>++</B> <B>--</B>       Increment and decrement, both prefix and post­
                   fix.

       <B>^</B>           Exponentiation  (<B>**</B>  may also be used, and <B>**=</B>
                   for the assignment operator).

       <B>+</B> <B>-</B> <B>!</B>       Unary plus, unary minus, and logical negation.

       <B>*</B> <B>/</B> <B>%</B>       Multiplication, division, and modulus.

       <B>+</B> <B>-</B>         Addition and subtraction.

       <I>space</I>       String concatenation.

       <B>&lt;</B> <B>&gt;</B>
       <B>&lt;=</B> <B>&gt;=</B>
       <B>!=</B> <B>==</B>       The regular relational operators.

       <B>~</B> <B>!~</B>        Regular   expression   match,  negated  match.
                   <B>NOTE:</B> Do not use a constant regular expression
                   (<B>/foo/</B>)  on  the  left-hand side of a <B>~</B> or <B>!~</B>.
                   Only use one  on  the  right-hand  side.   The
                   expression <B>/foo/</B> <B>~</B> <I>exp</I> has the same meaning as
                   <B>(($0</B> <B>~</B> <B>/foo/)</B> <B>~</B> <I>exp</I><B>)</B>.   This  is  usually  <I>not</I>
                   what was intended.

       <B>in</B>          Array membership.
                   forms) are supported.

   <B>Control</B> <B>Statements</B>
       The control statements are as follows:

              <B>if</B> <B>(</B><I>condition</I><B>)</B> <I>statement</I> [ <B>else</B> <I>statement</I> ]
              <B>while</B> <B>(</B><I>condition</I><B>)</B> <I>statement</I>
              <B>do</B> <I>statement</I> <B>while</B> <B>(</B><I>condition</I><B>)</B>
              <B>for</B> <B>(</B><I>expr1</I><B>;</B> <I>expr2</I><B>;</B> <I>expr3</I><B>)</B> <I>statement</I>
              <B>for</B> <B>(</B><I>var</I> <B>in</B> <I>array</I><B>)</B> <I>statement</I>
              <B>break</B>
              <B>continue</B>
              <B>delete</B> <I>array</I><B>[</B><I>index</I><B>]</B>
              <B>delete</B> <I>array</I>
              <B>exit</B> [ <I>expression</I> ]
              <B>{</B> <I>statements</I> <B>}</B>

   <B>I/O</B> <B>Statements</B>
       The input/output statements are as follows:


       <B>close(</B><I>file</I> [<B>,</B> <I>how</I>]<B>)</B>   Close file, pipe or co-process.  The
                             optional <I>how</I>  should  only  be  used
                             when  closing  one  end of a two-way
                             pipe to a co-process.  It must be  a
                             string value, either <B>"to"</B> or <B>"from"</B>.

       <B>getline</B>               Set <B>$0</B> from next input  record;  set
                             <B>NF</B>, <B>NR</B>, <B>FNR</B>.

       <B>getline</B> <B>&lt;</B><I>file</I>         Set <B>$0</B> from next record of <I>file</I>; set
                             <B>NF</B>.

       <B>getline</B> <I>var</I>           Set <I>var</I> from next input record;  set
                             <B>NR</B>, <B>FNR</B>.

       <B>getline</B> <I>var</I> <B>&lt;</B><I>file</I>     Set <I>var</I> from next record of <I>file</I>.

       <I>command</I> <B>|</B> <B>getline</B> [<I>var</I>]
                             Run <I>command</I> piping the output either
                             into <B>$0</B> or <I>var</I>, as above.

       <I>command</I> <B>|&amp;</B> <B>getline</B> [<I>var</I>]
                             Run <I>command</I> as a  co-process  piping
                             the output either into <B>$0</B> or <I>var</I>, as
                             above.   Co-processes  are  a   <I>gawk</I>
                             extension.

       <B>next</B>                  Stop  processing  the  current input
                             record.  The next  input  record  is
                             read and processing starts over with
                             the first pattern in  the  AWK  pro­

       <B>print</B>                 Prints the current record.  The out­
                             put record is  terminated  with  the
                             value of the <B>ORS</B> variable.

       <B>print</B> <I>expr-list</I>       Prints expressions.  Each expression
                             is separated by the value of the <B>OFS</B>
                             variable.  The output record is ter­
                             minated with the value  of  the  <B>ORS</B>
                             variable.

       <B>print</B> <I>expr-list</I> <B>&gt;</B><I>file</I> Prints  expressions  on  <I>file</I>.  Each
                             expression is separated by the value
                             of  the  <B>OFS</B>  variable.   The output
                             record is terminated with the  value
                             of the <B>ORS</B> variable.

       <B>printf</B> <I>fmt,</I> <I>expr-list</I> Format and print.

       <B>printf</B> <I>fmt,</I> <I>expr-list</I> <B>&gt;</B><I>file</I>
                             Format and print on <I>file</I>.

       <B>system(</B><I>cmd-line</I><B>)</B>      Execute  the  command  <I>cmd-line</I>, and
                             return the exit status.   (This  may
                             not  be  available on non-POSIX sys­
                             tems.)

       <B>fflush(</B>[<I>file</I>]<B>)</B>        Flush any  buffers  associated  with
                             the  open  output file or pipe <I>file</I>.
                             If <I>file</I> is  missing,  then  standard
                             output  is  flushed.  If <I>file</I> is the
                             null string, then  all  open  output
                             files  and  pipes have their buffers
                             flushed.

       Additional output redirections are allowed for  <B>print</B>  and
       <B>printf</B>.

       <B>print</B> <B>...</B> <B>&gt;&gt;</B> <I>file</I>
              appends output to the <I>file</I>.

       <B>print</B> <B>...</B> <B>|</B> <I>command</I>
              writes on a pipe.

       <B>print</B> <B>...</B> <B>|&amp;</B> <I>command</I>
              sends data to a co-process.

       The  <B>getline</B> command returns 0 on end of file and -1 on an
       error.  Upon an error, <B>ERRNO</B> contains a string  describing
       the problem.

       <B>NOTE:</B>  If  using  a pipe or co-process to <B>getline</B>, or from
       <B>print</B> or <B>printf</B> within a loop, you  <I>must</I>  use  <B>close()</B>  to

       <B>%d</B>, <B>%i</B>  A decimal number (the integer part).

       <B>%e</B> <B>,</B>  <B>%E</B>
               A    floating    point    number   of   the   form
               <B>[-]d.dddddde[+-]dd</B>.  The <B>%E</B> format uses <B>E</B>  instead
               of <B>e</B>.

       <B>%f</B>      A floating point number of the form <B>[-]ddd.dddddd</B>.

       <B>%g</B> <B>,</B>  <B>%G</B>
               Use <B>%e</B> or <B>%f</B>  conversion,  whichever  is  shorter,
               with nonsignificant zeros suppressed.  The <B>%G</B> for­
               mat uses <B>%E</B> instead of <B>%e</B>.

       <B>%o</B>      An unsigned octal number (also an integer).

       <B>%u</B>      An unsigned decimal number (again, an integer).

       <B>%s</B>      A character string.

       <B>%x</B> <B>,</B>  <B>%X</B>
               An unsigned hexadecimal number (an integer).   The
               <B>%X</B> format uses <B>ABCDEF</B> instead of <B>abcdef</B>.

       <B>%%</B>      A single <B>%</B> character; no argument is converted.

       Optional,  additional parameters may lie between the <B>%</B> and
       the control letter:

       <I>count</I><B>$</B> Use the <I>count</I>'th argument at this point in the for­
              matting.  This is called a <I>positional</I> <I>specifier</I> and
              is intended primarily for use  in  translated  ver­
              sions  of  format strings, not in the original text
              of an AWK program.  It is a <I>gawk</I> extension.

       <B>-</B>      The expression should be left-justified within  its
              field.

       <I>space</I>  For  numeric  conversions,  prefix  positive values
              with a space, and  negative  values  with  a  minus
              sign.

       <B>+</B>      The  plus sign, used before the width modifier (see
              below), says to always supply a  sign  for  numeric
              conversions,  even  if  the data to be formatted is
              positive.  The <B>+</B> overrides the space modifier.

       <B>#</B>      Use an "alternate form" for  certain  control  let­
              ters.   For <B>%o</B>, supply a leading zero.  For <B>%x</B>, and
              <B>%X</B>, supply a leading <B>0x</B> or <B>0X</B> for a nonzero result.
              For  <B>%e</B>,  <B>%E</B>,  and <B>%f</B>, the result always contains a
              printing.   For  the  <B>%e</B>,  <B>%E</B>, and <B>%f</B> formats, this
              specifies the number of digits you want printed  to
              the right of the decimal point.  For the <B>%g</B>, and <B>%G</B>
              formats, it specifies the maximum number of signif­
              icant  digits.   For the <B>%d</B>, <B>%o</B>, <B>%i</B>, <B>%u</B>, <B>%x</B>, and <B>%X</B>
              formats, it specifies the minimum number of  digits
              to  print.  For <B>%s</B>, it specifies the maximum number
              of  characters  from  the  string  that  should  be
              printed.

       The  dynamic  <I>width</I>  and  <I>prec</I>  capabilities of the ANSI C
       <B>printf()</B> routines are supported.  A <B>*</B> in place  of  either
       the <B>width</B> or <B>prec</B> specifications causes their values to be
       taken from the argument list to <B>printf</B> or  <B>sprintf()</B>.   To
       use  a positional specifier with a dynamic width or preci­
       sion, supply the <I>count</I><B>$</B> after the <B>*</B> in the format  string.
       For example, <B>"%3$*2$.*1$s"</B>.

   <B>Special</B> <B>File</B> <B>Names</B>
       When  doing  I/O  redirection  from either <B>print</B> or <B>printf</B>
       into a file, or via <B>getline</B> from a file,  <I>gawk</I>  recognizes
       certain  special  filenames  internally.   These filenames
       allow access  to  open  file  descriptors  inherited  from
       <I>gawk</I>'s  parent  process  (usually  the shell).  These file
       names may also be used on the command line  to  name  data
       files.  The filenames are:

       <B>/dev/stdin</B>  The standard input.

       <B>/dev/stdout</B> The standard output.

       <B>/dev/stderr</B> The standard error output.

       <B>/dev/fd/</B><I>n</I>   The   file   associated  with  the  open  file
                   descriptor <I>n</I>.

       These are particularly useful  for  error  messages.   For
       example:

              <B>print</B> <B>"You</B> <B>blew</B> <B>it!"</B> <B>&gt;</B> <B>"/dev/stderr"</B>

       whereas you would otherwise have to use

              <B>print</B> <B>"You</B> <B>blew</B> <B>it!"</B> <B>|</B> <B>"cat</B> <B>1&gt;&amp;2"</B>

       The  following  special  filenames may be used with the <B>|&amp;</B>
       co-process operator for creating  TCP/IP  network  connec­
       tions.

       <B>/inet/tcp/</B><I>lport</I><B>/</B><I>rhost</I><B>/</B><I>rport</I>  File for TCP/IP connection on
                                    local port  <I>lport</I>  to  remote
                                    host  <I>rhost</I>  on  remote  port

                   the  current  process,  in decimal, terminated
                   with a newline.

       <B>/dev/ppid</B>   Reading this file returns the  parent  process
                   ID  of the current process, in decimal, termi­
                   nated with a newline.

       <B>/dev/pgrpid</B> Reading this file returns the process group ID
                   of the current process, in decimal, terminated
                   with a newline.

       <B>/dev/user</B>   Reading this file returns a single record ter­
                   minated  with a newline.  The fields are sepa­
                   rated with spaces.  <B>$1</B> is  the  value  of  the
                   <B>getuid(2)</B>  system call, <B>$2</B> is the value of the
                   <B>geteuid(2)</B> system call, <B>$3</B> is the value of the
                   <B>getgid(2)</B>  system call, and <B>$4</B> is the value of
                   the <B>getegid(2)</B> system call.  If there are  any
                   additional  fields,  they  are  the  group IDs
                   returned by <B>getgroups(2)</B>.  Multiple groups may
                   not be supported on all systems.

   <B>Numeric</B> <B>Functions</B>
       AWK has the following built-in arithmetic functions:


       <B>atan2(</B><I>y</I><B>,</B> <I>x</I><B>)</B>   Returns the arctangent of <I>y/x</I> in radians.

       <B>cos(</B><I>expr</I><B>)</B>     Returns  the  cosine  of  <I>expr</I>,  which is in
                     radians.

       <B>exp(</B><I>expr</I><B>)</B>     The exponential function.

       <B>int(</B><I>expr</I><B>)</B>     Truncates to integer.

       <B>log(</B><I>expr</I><B>)</B>     The natural logarithm function.

       <B>rand()</B>        Returns a random number between 0 and 1.

       <B>sin(</B><I>expr</I><B>)</B>     Returns the sine of <I>expr</I>, which is in  radi­
                     ans.

       <B>sqrt(</B><I>expr</I><B>)</B>    The square root function.

       <B>srand(</B>[<I>expr</I>]<B>)</B> Uses  <I>expr</I> as a new seed for the random num­
                     ber generator.  If no <I>expr</I> is provided,  the
                     time  of  day  is used.  The return value is
                     the previous seed for the random number gen­
                     erator.

   <B>String</B> <B>Functions</B>
       <I>Gawk</I> has the following built-in string functions:

       <B>gensub(</B><I>r</I><B>,</B> <I>s</I><B>,</B> <I>h</I> [<B>,</B> <I>t</I>]<B>)</B>   Search the  target  string  <I>t</I>  for
                               matches  of the regular expression
                               <I>r</I>.  If <I>h</I>  is  a  string  beginning
                               with  <B>g</B>  or  <B>G</B>,  then  replace all
                               matches of <I>r</I> with <I>s</I>.  Otherwise, <I>h</I>
                               is a number indicating which match
                               of <I>r</I> to replace.  If <I>t</I> is not sup­
                               plied, <B>$0</B> is used instead.  Within
                               the  replacement   text   <I>s</I>,   the
                               sequence  <B>\</B><I>n</I>,  where  <I>n</I> is a digit
                               from 1 to 9, may be used to  indi­
                               cate  just  the  text that matched
                               the <I>n</I>'th parenthesized  subexpres­
                               sion.   The sequence <B>\0</B> represents
                               the entire matched text,  as  does
                               the character <B>&amp;</B>.  Unlike <B>sub()</B> and
                               <B>gsub()</B>,  the  modified  string  is
                               returned  as  the  result  of  the
                               function, and the original  target
                               string is <I>not</I> changed.

       <B>gsub(</B><I>r</I><B>,</B> <I>s</I> [<B>,</B> <I>t</I>]<B>)</B>        For  each  substring  matching the
                               regular expression <I>r</I> in the string
                               <I>t</I>,  substitute  the  string <I>s</I>, and
                               return  the  number  of  substitu­
                               tions.   If <I>t</I> is not supplied, use
                               <B>$0</B>.  An <B>&amp;</B> in the replacement  text
                               is replaced with the text that was
                               actually matched.  Use <B>\&amp;</B> to get a
                               literal <B>&amp;</B>.  (This must be typed as
                               <B>"\\&amp;"</B>;  see  <I>GAWK:</I>  <I>Effective</I>  <I>AWK</I>
                               <I>Programming</I>  for  a fuller discus­
                               sion of  the  rules  for  <B>&amp;'s</B>  and
                               backslashes   in  the  replacement
                               text of <B>sub()</B>,  <B>gsub()</B>,  and  <B>gen­</B>
                               <B>sub()</B>.)

       <B>index(</B><I>s</I><B>,</B> <I>t</I><B>)</B>             Returns  the index of the string <I>t</I>
                               in the string <I>s</I>, or 0 if <I>t</I> is  not
                               present.  (This implies that char­
                               acter indices start at one.)

       <B>length(</B>[<I>s</I>]<B>)</B>             Returns the length of  the  string
                               <I>s</I>, or the length of <B>$0</B> if <I>s</I> is not
                               supplied.

       <B>match(</B><I>s</I><B>,</B> <I>r</I> [<B>,</B> <I>a</I>]<B>)</B>       Returns the position  in  <I>s</I>  where
                               the  regular  expression <I>r</I> occurs,
                               or 0 if <I>r</I> is not present, and sets
                               the  values of <B>RSTART</B> and <B>RLENGTH</B>.
                               Note that the  argument  order  is
                               <I>r</I>  is omitted, <B>FS</B> is used instead.
                               The  array  <I>a</I>  is  cleared  first.
                               Splitting  behaves  identically to
                               field splitting, described  above.

       <B>sprintf(</B><I>fmt</I><B>,</B> <I>expr-list</I><B>)</B> Prints <I>expr-list</I> according to <I>fmt</I>,
                               and returns the resulting  string.

       <B>strtonum(</B><I>str</I><B>)</B>           Examines   <I>str</I>,  and  returns  its
                               numeric value.  If <I>str</I> begins with
                               a  leading  <B>0</B>,  <B>strtonum()</B> assumes
                               that <I>str</I> is an octal  number.   If
                               <I>str</I>  begins  with  a leading <B>0x</B> or
                               <B>0X</B>, <B>strtonum()</B> assumes that <I>str</I> is
                               a hexadecimal number.

       <B>sub(</B><I>r</I><B>,</B> <I>s</I> [<B>,</B> <I>t</I>]<B>)</B>         Just  like  <B>gsub()</B>,  but  only the
                               first   matching   substring    is
                               replaced.

       <B>substr(</B><I>s</I><B>,</B> <I>i</I> [<B>,</B> <I>n</I>]<B>)</B>      Returns  the  at  most <I>n</I>-character
                               substring of <I>s</I> starting at <I>i</I>.   If
                               <I>n</I>  is  omitted,  the  rest of <I>s</I> is
                               used.

       <B>tolower(</B><I>str</I><B>)</B>            Returns a copy of the string  <I>str</I>,
                               with all the upper-case characters
                               in <I>str</I> translated to their  corre­
                               sponding  lower-case counterparts.
                               Non-alphabetic characters are left
                               unchanged.

       <B>toupper(</B><I>str</I><B>)</B>            Returns  a copy of the string <I>str</I>,
                               with all the lower-case characters
                               in  <I>str</I> translated to their corre­
                               sponding upper-case  counterparts.
                               Non-alphabetic characters are left
                               unchanged.

   <B>Time</B> <B>Functions</B>
       Since one of the primary uses of AWK programs is  process­
       ing  log  files  that contain time stamp information, <I>gawk</I>
       provides the following functions for obtaining time stamps
       and formatting them.


       <B>mktime(</B><I>datespec</I><B>)</B>
                 Rurns  <I>datespec</I>  into  a  time stamp of the same
                 form as returned by <B>systime()</B>.  The <I>datespec</I>  is
                 a  string of the form <I>YYYY</I> <I>MM</I> <I>DD</I> <I>HH</I> <I>MM</I> <I>SS[</I> <I>DST]</I>.
                 The contents of the string are six or seven num­
                 bers  representing  respectively  the  full year
                 default), <B>mktime()</B> attempts to determine whether
                 daylight saving time is in effect for the speci­
                 fied time.  If <I>datespec</I> does not contain  enough
                 elements  or  if  the  resulting  time is out of
                 range, <B>mktime()</B> returns -1.

       <B>strftime(</B>[<I>format</I> [<B>,</B> <I>timestamp</I>]]<B>)</B>
                 Formats <I>timestamp</I> according to the specification
                 in  <I>format.</I>  The <I>timestamp</I> should be of the same
                 form as returned by <B>systime()</B>.  If <I>timestamp</I>  is
                 missing,  the  current  time of day is used.  If
                 <I>format</I> is missing, a default  format  equivalent
                 to the output of <B>date(1)</B> is used.  See the spec­
                 ification for the <B>strftime()</B> function in ANSI  C
                 for  the  format conversions that are guaranteed
                 to be available.   A  public-domain  version  of
                 <B>strftime(3)</B>  and  a  man  page  for it come with
                 <I>gawk</I>; if that version was used  to  build  <I>gawk</I>,
                 then  all  of  the conversions described in that
                 man page are available to <I>gawk.</I>

       <B>systime()</B> Returns the current time of day as the number of
                 seconds since the Epoch (1970-01-01 00:00:00 UTC
                 on POSIX systems).

   <B>Bit</B> <B>Manipulations</B> <B>Functions</B>
       Starting with version  3.1  of  <I>gawk</I>,  the  following  bit
       manipulation  functions  are available.  They work by con­
       verting double-precision floating point values to <B>unsigned</B>
       <B>long</B>  integers,  doing  the operation, and then converting
       the result back to floating point.  The functions are:

       <B>and(</B><I>v1</I><B>,</B> <I>v2</I><B>)</B>         Return the bitwise AND of  the  values
                           provided by <I>v1</I> and <I>v2</I>.

       <B>compl(</B><I>val</I><B>)</B>          Return  the bitwise complement of <I>val</I>.

       <B>lshift(</B><I>val</I><B>,</B> <I>count</I><B>)</B>  Return the value of <I>val</I>, shifted  left
                           by <I>count</I> bits.

       <B>or(</B><I>v1</I><B>,</B> <I>v2</I><B>)</B>          Return  the  bitwise  OR of the values
                           provided by <I>v1</I> and <I>v2</I>.

       <B>rshift(</B><I>val</I><B>,</B> <I>count</I><B>)</B>  Return the value of <I>val</I>, shifted right
                           by <I>count</I> bits.

       <B>xor(</B><I>v1</I><B>,</B> <I>v2</I><B>)</B>         Return  the  bitwise XOR of the values
                           provided by <I>v1</I> and <I>v2</I>.


   <B>Internationalization</B> <B>Functions</B>
       Starting with version 3.1 of <I>gawk</I>, the following functions

       <B>dcgettext(</B><I>string</I> [<B>,</B> <I>domain</I> [<B>,</B> <I>category</I>]]<B>)</B>
              Returns the translation of <I>string</I>  in  text  domain
              <I>domain</I>  for  locale category <I>category</I>.  The default
              value for <I>domain</I> is the current  value  of  <B>TEXTDO­</B>
              <B>MAIN</B>.   The  default value for <I>category</I> is <B>"LC_MES­</B>
              <B>SAGES"</B>.
              If you supply a value for <I>category</I>, it  must  be  a
              string  equal to one of the known locale categories
              described in <I>GAWK:</I> <I>Effective</I> <I>AWK</I> <I>Programming</I>.   You
              must  also supply a text domain.  Use <B>TEXTDOMAIN</B> if
              you want to use the current domain.

       <B>dcngettext(</B><I>string1</I> , <I>string2</I> , <I>number</I> [<B>,</B> <I>domain</I>  [<B>,</B>  <I>cate­</I>
       <I>gory</I>]]<B>)</B>
              Returns the plural form  used  for  <I>number</I>  of  the
              translation  of  <I>string1</I> and <I>string2</I> in text domain
              <I>domain</I> for locale category <I>category</I>.   The  default
              value  for  <I>domain</I>  is the current value of <B>TEXTDO­</B>
              <B>MAIN</B>.  The default value for <I>category</I>  is  <B>"LC_MES­</B>
              <B>SAGES"</B>.
              If  you  supply  a value for <I>category</I>, it must be a
              string equal to one of the known locale  categories
              described  in <I>GAWK:</I> <I>Effective</I> <I>AWK</I> <I>Programming</I>.  You
              must also supply a text domain.  Use <B>TEXTDOMAIN</B>  if
              you want to use the current domain.


</PRE>
<H2>USER-DEFINED FUNCTIONS</H2><PRE>
       Functions in AWK are defined as follows:

              <B>function</B> <I>name</I><B>(</B><I>parameter</I> <I>list</I><B>)</B> <B>{</B> <I>statements</I> <B>}</B>

       Functions  are  executed  when they are called from within
       expressions in either patterns or actions.  Actual parame­
       ters supplied in the function call are used to instantiate
       the formal parameters declared in  the  function.   Arrays
       are  passed  by  reference,  other variables are passed by
       value.

       Since functions were not originally part of the  AWK  lan­
       guage, the provision for local variables is rather clumsy:
       They are declared as extra  parameters  in  the  parameter
       list.   The convention is to separate local variables from
       real parameters by extra spaces  in  the  parameter  list.
       For example:

              <B>function</B>  <B>f(p,</B> <B>q,</B>     <B>a,</B> <B>b)</B>   <B>#</B> <B>a</B> <B>and</B> <B>b</B> <B>are</B> <B>local</B>
              <B>{</B>
                   <B>...</B>
              <B>}</B>

              <B>/abc/</B>     <B>{</B> <B>...</B> <B>;</B> <B>f(1,</B> <B>2)</B> <B>;</B> <B>...</B> <B>}</B>

       the function returns by "falling off" the end.

       If <B>--lint</B> has been provided, <I>gawk</I>  warns  about  calls  to
       undefined functions at parse time, instead of at run time.
       Calling an undefined function  at  run  time  is  a  fatal
       error.

       The word <B>func</B> may be used in place of <B>function</B>.


</PRE>
<H2>DYNAMICALLY LOADING NEW FUNCTIONS</H2><PRE>
       Beginning  with  version  3.1 of <I>gawk</I>, you can dynamically
       add new built-in functions  to  the  running  <I>gawk</I>  inter­
       preter.   The  full  details  are beyond the scope of this
       manual page; see <I>GAWK:</I> <I>Effective</I> <I>AWK</I> <I>Programming</I>  for  the
       details.


       <B>extension(</B><I>object</I><B>,</B> <I>function</I><B>)</B>
               Dynamically  link  the shared object file named by
               <I>object</I>, and invoke <I>function</I>  in  that  object,  to
               perform initialization.  These should both be pro­
               vided as strings.  Returns the value  returned  by
               <I>function</I>.

       <B>This</B>  <B>function</B>  <B>is</B> <B>provided</B> <B>and</B> <B>documented</B> <B>in</B> <I>GAWK:</I> <I>Effec­</I>
       <I>tive</I> <I>AWK</I> <I>Programming</I><B>,</B> <B>but</B> <B>everything</B> <B>about</B> <B>this</B> <B>feature</B> <B>is</B>
       <B>likely</B>  <B>to</B> <B>change</B> <B>in</B> <B>the</B> <B>next</B> <B>release.</B>  <B>We</B> <B>STRONGLY</B> <B>recom­</B>
       <B>mend</B> <B>that</B> <B>you</B> <B>do</B> <B>not</B> <B>use</B> <B>this</B> <B>feature</B>  <B>for</B>  <B>anything</B>  <B>that</B>
       <B>you</B> <B>aren't</B> <B>willing</B> <B>to</B> <B>redo.</B>


</PRE>
<H2>SIGNALS</H2><PRE>
       <I>pgawk</I>  accepts  two  signals.  <B>SIGUSR1</B> causes it to dump a
       profile and function call stack to the profile file, which
       is either <B>awkprof.out</B>, or whatever file was named with the
       <B>--profile</B> option.   It  then  continues  to  run.   <B>SIGHUP</B>
       causes  it to dump the profile and function call stack and
       then exit.


</PRE>
<H2>EXAMPLES</H2><PRE>
       Print and sort the login names of all users:

            <B>BEGIN</B>     <B>{</B> <B>FS</B> <B>=</B> <B>":"</B> <B>}</B>
                 <B>{</B> <B>print</B> <B>$1</B> <B>|</B> <B>"sort"</B> <B>}</B>

       Count lines in a file:

                 <B>{</B> <B>nlines++</B> <B>}</B>
            <B>END</B>  <B>{</B> <B>print</B> <B>nlines</B> <B>}</B>

       Precede each line by its number in the file:

            <B>{</B> <B>print</B> <B>FNR,</B> <B>$0</B> <B>}</B>

       always prints <B>hello,</B> <B>world</B>.  But,

              <B>gawk</B> <B>'BEGIN</B> <B>{</B> <B>print</B> <B>_"hello,</B> <B>world"</B> <B>}'</B>

       might print <B>bonjour,</B> <B>monde</B> in France.

       There  are several steps involved in producing and running
       a localizable AWK program.

       1.  Add a <B>BEGIN</B> action to assign a value to the <B>TEXTDOMAIN</B>
           variable  to  set the text domain to a name associated
           with your program.

                <B>BEGIN</B> <B>{</B> <B>TEXTDOMAIN</B> <B>=</B> <B>"myprog"</B> <B>}</B>

           This allows <I>gawk</I> to find the <B>.mo</B> file associated  with
           your  program.   Without this step, <I>gawk</I> uses the <B>mes­</B>
           <B>sages</B> text  domain,  which  likely  does  not  contain
           translations for your program.

       2.  Mark  all strings that should be translated with lead­
           ing underscores.

       3.  If necessary, use the <B>dcgettext()</B>  and/or  <B>bindtextdo­</B>
           <B>main()</B> functions in your program, as appropriate.

       4.  Run  <B>gawk</B> <B>--gen-po</B> <B>-f</B> <B>myprog.awk</B> <B>&gt;</B> <B>myprog.po</B> to gener­
           ate a <B>.po</B> file for your program.

       5.  Provide  appropriate  translations,  and   build   and
           install a corresponding <B>.mo</B> file.

       The  internationalization  features  are described in full
       detail in <I>GAWK:</I> <I>Effective</I> <I>AWK</I> <I>Programming</I>.


</PRE>
<H2>POSIX COMPATIBILITY</H2><PRE>
       A primary goal for <I>gawk</I> is compatibility  with  the  POSIX
       standard,  as well as with the latest version of UNIX <I>awk</I>.
       To this end, <I>gawk</I> incorporates the following user  visible
       features  which are not described in the AWK book, but are
       part of the Bell Laboratories version of <I>awk</I>, and  are  in
       the POSIX standard.

       The  book  indicates that command line variable assignment
       happens when <I>awk</I> would otherwise open the  argument  as  a
       file,  which  is  after the <B>BEGIN</B> block is executed.  How­
       ever, in earlier implementations, when such an  assignment
       appeared  before any file names, the assignment would hap­
       pen <I>before</I> the <B>BEGIN</B> block was run.  Applications came  to
       depend  on  this "feature."  When <I>awk</I> was changed to match
       its documentation, the <B>-v</B> option for  assigning  variables
       The  AWK book does not define the return value of <B>srand()</B>.
       The POSIX standard has it return the seed it was using, to
       allow keeping track of random number sequences.  Therefore
       <B>srand()</B> in <I>gawk</I> also returns its current seed.

       Other new features are: The use  of  multiple  <B>-f</B>  options
       (from  MKS  <I>awk</I>); the <B>ENVIRON</B> array; the <B>\a</B>, and <B>\v</B> escape
       sequences (done originally in <I>gawk</I> and fed back  into  the
       Bell  Laboratories  version);  the <B>tolower()</B> and <B>toupper()</B>
       built-in functions (from the Bell  Laboratories  version);
       and  the  ANSI C conversion specifications in <B>printf</B> (done
       first in the Bell Laboratories version).


</PRE>
<H2>HISTORICAL FEATURES</H2><PRE>
       There are two features of historical  AWK  implementations
       that  <I>gawk</I>  supports.   First,  it is possible to call the
       <B>length()</B> built-in function not only with no argument,  but
       even without parentheses!  Thus,

              <B>a</B> <B>=</B> <B>length</B>     <B>#</B> <B>Holy</B> <B>Algol</B> <B>60,</B> <B>Batman!</B>

       is the same as either of

              <B>a</B> <B>=</B> <B>length()</B>
              <B>a</B> <B>=</B> <B>length($0)</B>

       This  feature is marked as "deprecated" in the POSIX stan­
       dard, and <I>gawk</I> issues a warning about its use if <B>--lint</B> is
       specified on the command line.

       The other feature is the use of either the <B>continue</B> or the
       <B>break</B> statements outside the body of a <B>while</B>, <B>for</B>,  or  <B>do</B>
       loop.   Traditional  AWK implementations have treated such
       usage as equivalent to the <B>next</B> statement.  <I>Gawk</I>  supports
       this usage if <B>--traditional</B> has been specified.


</PRE>
<H2>GNU EXTENSIONS</H2><PRE>
       <I>Gawk</I>  has  a  number of extensions to POSIX <I>awk</I>.  They are
       described in this section.  All the  extensions  described
       here  can  be  disabled by invoking <I>gawk</I> with the <B>--tradi­</B>
       <B>tional</B> option.

       The following features of <I>gawk</I> are not available in  POSIX
       <I>awk</I>.

       · No  path  search is performed for files named via the <B>-f</B>
         option.  Therefore the <B>AWKPATH</B> environment  variable  is
         not special.

       · The <B>\x</B> escape sequence.  (Disabled with <B>--posix</B>.)

       · The <B>fflush()</B> function.  (Disabled with <B>--posix</B>.)

       · The <B>PROCINFO</B> array is not available.

       · The use of <B>RS</B> as a regular expression.

       · The special file names available for I/O redirection are
         not recognized.

       · The <B>|&amp;</B> operator for creating co-processes.

       · The ability to split out individual characters using the
         null  string  as the value of <B>FS</B>, and as the third argu­
         ment to <B>split()</B>.

       · The optional second argument to the <B>close()</B> function.

       · The optional third argument to the <B>match()</B> function.

       · The ability to use positional specifiers with <B>printf</B> and
         <B>sprintf()</B>.

       · The use of <B>delete</B> <I>array</I> to delete the entire contents of
         an array.

       · The use of <B>nextfile</B> to abandon processing of the current
         input file.

       · The  <B>and()</B>,  <B>asort()</B>,  <B>bindtextdomain()</B>, <B>compl()</B>, <B>dcget­</B>
         <B>text()</B>, <B>gensub()</B>, <B>lshift()</B>,  <B>mktime()</B>,  <B>or()</B>,  <B>rshift()</B>,
         <B>strftime()</B>, <B>strtonum()</B>, <B>systime()</B> and <B>xor()</B> functions.

       · Localizable strings.

       · Adding  new  built-in  functions  dynamically  with  the
         <B>extension()</B> function.

       The AWK book does not  define  the  return  value  of  the
       <B>close()</B>  function.   <I>Gawk</I>'s <B>close()</B> returns the value from
       <B>fclose(3)</B>, or <B>pclose(3)</B>, when closing an  output  file  or
       pipe,  respectively.  It returns the process's exit status
       when closing an input pipe.  The return value is -1 if the
       named file, pipe or co-process was not opened with a redi­
       rection.

       When <I>gawk</I> is invoked with the <B>--traditional</B> option, if the
       <I>fs</I> argument to the <B>-F</B> option is "t", then <B>FS</B> is set to the
       tab character.  Note that typing  <B>gawk</B>  <B>-F\t</B>  <B>...</B>   simply
       causes the shell to quote the "t,", and does not pass "\t"
       to the <B>-F</B> option.  Since this is  a  rather  ugly  special
       case,  it is not the default behavior.  This behavior also
       does not occur if <B>--posix</B> has been specified.   To  really
       get  a tab character as the field separator, it is best to
       <B>geteuid(2)</B>, <B>getgid(2)</B>, <B>getegid(2)</B>, <B>getgroups(2)</B>

       <I>The</I> <I>AWK</I> <I>Programming</I> <I>Language</I>,  Alfred  V.  Aho,  Brian  W.
       Kernighan,  Peter  J.  Weinberger,  Addison-Wesley,  1988.
       ISBN 0-201-07981-X.

       <I>GAWK:</I> <I>Effective</I> <I>AWK</I> <I>Programming</I>, Edition 3.0, published by
       the Free Software Foundation, 2001.


</PRE>
<H2>BUGS</H2><PRE>
       The  <B>-F</B>  option  is  not  necessary given the command line
       variable assignment feature; it remains only for backwards
       compatibility.

       Syntactically  invalid  single  character programs tend to
       overflow the parse stack, generating  a  rather  unhelpful
       message.   Such  programs  are  surprisingly  difficult to
       diagnose in the completely general case, and the effort to
       do so really is not worth it.


</PRE>
<H2>AUTHORS</H2><PRE>
       The  original  version of UNIX <I>awk</I> was designed and imple­
       mented  by  Alfred  Aho,  Peter  Weinberger,   and   Brian
       Kernighan of Bell Laboratories.  Brian Kernighan continues
       to maintain and enhance it.

       Paul Rubin and Jay Fenlason, of the Free Software  Founda­
       tion,  wrote <I>gawk</I>, to be compatible with the original ver­
       sion of <I>awk</I> distributed in  Seventh  Edition  UNIX.   John
       Woods  contributed  a number of bug fixes.  David Trueman,
       with contributions from Arnold Robbins, made <I>gawk</I> compati­
       ble  with  the new version of UNIX <I>awk</I>.  Arnold Robbins is
       the current maintainer.

       The initial DOS port was done by  Conrad  Kwok  and  Scott
       Garfinkle.   Scott  Deifik  is the current DOS maintainer.
       Pat Rankin did the port to VMS, and Michal Jaegermann  did
       the  port  to  the Atari ST.  The port to OS/2 was done by
       Kai Uwe Rommel, with contributions and  help  from  Darrel
       Hankerson.   Fred  Fish  supplied  support  for the Amiga,
       Stephen Davies provided the Tandem port, and Martin  Brown
       provided the BeOS port.


</PRE>
<H2>VERSION INFORMATION</H2><PRE>
       This man page documents <I>gawk</I>, version 3.1.0.


</PRE>
<H2>BUG REPORTS</H2><PRE>
       If  you find a bug in <I>gawk</I>, please send electronic mail to
       <B>bug-gawk@gnu.org</B>.  Please include  your  operating  system
       and  its  revision,  the version of <I>gawk</I> (from <B>gawk</B> <B>--ver­</B>
       <B>sion</B>), what C compiler you used to compile it, and a  test
       program  and data that are as small as possible for repro­
       liable way to report bugs.  Instead, please use the  elec­
       tronic mail addresses given above.


</PRE>
<H2>ACKNOWLEDGEMENTS</H2><PRE>
       Brian  Kernighan  of  Bell  Laboratories provided valuable
       assistance during testing and debugging.  We thank him.


</PRE>
<H2>COPYING PERMISSIONS</H2><PRE>
       Copyright © 1989, 1991,  1992,  1993,  1994,  1995,  1996,
       1997,  1998,  1999,  2001,  2002 Free Software Foundation,
       Inc.

       Permission is granted  to  make  and  distribute  verbatim
       copies  of  this manual page provided the copyright notice
       and this permission notice are preserved on all copies.

       Permission is granted to copy and distribute modified ver­
       sions  of this manual page under the conditions for verba­
       tim copying, provided that the  entire  resulting  derived
       work is distributed under the terms of a permission notice
       identical to this one.

       Permission is granted to copy and distribute  translations
       of this manual page into another language, under the above
       conditions for modified versions, except that this permis­
       sion notice may be stated in a translation approved by the
       Foundation.



Free Software Foundation   Apr 16 2002                    <B>GAWK(1)</B>
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
