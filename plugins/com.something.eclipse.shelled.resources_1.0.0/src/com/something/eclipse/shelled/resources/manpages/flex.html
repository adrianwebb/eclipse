<HTML>
<BODY>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->

</PRE>
<H2>SYNOPSIS</H2><PRE>
       <B>flex</B>  <B>[-bcdfhilnpstvwBFILTV78+?</B> <B>-C[aefFmr]</B> <B>-ooutput</B> <B>-Ppre­</B>
       <B>fix</B> <B>-Sskeleton]</B> <B>[--help</B> <B>--version]</B> <I>[filename</I> <I>...]</I>


</PRE>
<H2>OVERVIEW</H2><PRE>
       This manual describes <I>flex,</I> a tool for generating programs
       that   perform   pattern-matching  on  text.   The  manual
       includes both tutorial and reference sections:

           Description
               a brief overview of the tool

           Some Simple Examples

           Format Of The Input File

           Patterns
               the extended regular expressions used by flex

           How The Input Is Matched
               the rules for determining what has been matched

           Actions
               how to specify what to do when a pattern is matched

           The Generated Scanner
               details regarding the scanner that flex produces;
               how to control the input source

           Start Conditions
               introducing context into your scanners, and
               managing "mini-scanners"

           Multiple Input Buffers
               how to manipulate multiple input sources; how to
               scan from strings instead of files

           End-of-file Rules
               special rules for matching the end of the input

           Miscellaneous Macros
               a summary of macros available to the actions

           Values Available To The User
               a summary of values available to the actions

           Interfacing With Yacc
               connecting flex scanners together with yacc parsers

           Options
               flex command-line options, and the "%option"
               directive
               it generates) whose meanings might not be apparent

           Files
               files used by flex

           Deficiencies / Bugs
               known problems with flex

           See Also
               other documentation, related tools

           Author
               includes contact information



</PRE>
<H2>DESCRIPTION</H2><PRE>
       <I>flex</I> is a tool for  generating  <I>scanners:</I>  programs  which
       recognized lexical patterns in text.  <I>flex</I> reads the given
       input files, or its standard input if no  file  names  are
       given,  for  a  description of a scanner to generate.  The
       description is in the form of pairs of regular expressions
       and  C  code,  called  <I>rules.</I> <I>flex</I> generates as output a C
       source file, <B>lex.yy.c,</B> which defines  a  routine  <B>yylex().</B>
       This  file is compiled and linked with the <B>-lfl</B> library to
       produce an executable.  When the  executable  is  run,  it
       analyzes  its input for occurrences of the regular expres­
       sions.  Whenever it finds one, it executes the correspond­
       ing C code.


</PRE>
<H2>SOME SIMPLE EXAMPLES</H2><PRE>
       First  some  simple  examples to get the flavor of how one
       uses <I>flex.</I>  The following <I>flex</I> input specifies  a  scanner
       which  whenever  it  encounters the string "username" will
       replace it with the user's login name:

           %%
           username    printf( "%s", getlogin() );

       By default, any text not matched  by  a  <I>flex</I>  scanner  is
       copied to the output, so the net effect of this scanner is
       to copy its input file to its output with each  occurrence
       of  "username" expanded.  In this input, there is just one
       rule.  "username" is the <I>pattern</I> and the "printf"  is  the
       <I>action.</I>  The "%%" marks the beginning of the rules.

       Here's another simple example:

                   int num_lines = 0, num_chars = 0;

           %%
           \n      ++num_lines; ++num_chars;
           .       ++num_chars;

       tine declared after the second "%%".  There are two rules,
       one which matches a newline ("\n") and increments both the
       line count and the character count, and one which  matches
       any  character  other than a newline (indicated by the "."
       regular expression).

       A somewhat more complicated example:

           /* scanner for a toy Pascal-like language */

           %{
           /* need this for the call to atof() below */
           #include &lt;math.h&gt;
           %}

           DIGIT    [0-9]
           ID       [a-z][a-z0-9]*

           %%

           {DIGIT}+    {
                       printf( "An integer: %s (%d)\n", yytext,
                               atoi( yytext ) );
                       }

           {DIGIT}+"."{DIGIT}*        {
                       printf( "A float: %s (%g)\n", yytext,
                               atof( yytext ) );
                       }

           if|then|begin|end|procedure|function        {
                       printf( "A keyword: %s\n", yytext );
                       }

           {ID}        printf( "An identifier: %s\n", yytext );

           "+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );

           "{"[^}\n]*"}"     /* eat up one-line comments */

           [ \t\n]+          /* eat up whitespace */

           .           printf( "Unrecognized character: %s\n", yytext );

           %%

           main( argc, argv )
           int argc;
           char **argv;
               {
               ++argv, --argc;  /* skip over program name */
               if ( argc &gt; 0 )


</PRE>
<H2>FORMAT OF THE INPUT FILE</H2><PRE>
       The  <I>flex</I> input file consists of three sections, separated
       by a line with just <B>%%</B> in it:

           definitions
           %%
           rules
           %%
           user code

       The <I>definitions</I> section contains  declarations  of  simple
       <I>name</I>  definitions  to  simplify the scanner specification,
       and declarations of <I>start</I> <I>conditions,</I> which are  explained
       in a later section.

       Name definitions have the form:

           name definition

       The  "name" is a word beginning with a letter or an under­
       score ('_') followed by zero or more letters, digits, '_',
       or  '-'  (dash).   The definition is taken to begin at the
       first non-white-space character  following  the  name  and
       continuing  to  the  end  of the line.  The definition can
       subsequently be referred to  using  "{name}",  which  will
       expand to "(definition)".  For example,

           DIGIT    [0-9]
           ID       [a-z][a-z0-9]*

       defines "DIGIT" to be a regular expression which matches a
       single digit, and "ID" to be a  regular  expression  which
       matches  a letter followed by zero-or-more letters-or-dig­
       its.  A subsequent reference to

           {DIGIT}+"."{DIGIT}*

       is identical to

           ([0-9])+"."([0-9])*

       and matches one-or-more digits followed by a '.'  followed
       by zero-or-more digits.

       The  <I>rules</I>  section of the <I>flex</I> input contains a series of
       rules of the form:

           pattern   action

       where the pattern must be unindented and the  action  must
       begin on the same line.

       In  the  rules section, any indented or %{} text appearing
       before the first rule may be  used  to  declare  variables
       which  are  local  to  the scanning routine and (after the
       declarations) code which is to be  executed  whenever  the
       scanning  routine  is entered.  Other indented or %{} text
       in the rule section is still copied to the output, but its
       meaning is not well-defined and it may well cause compile-
       time errors (this feature is present for <I>POSIX</I> compliance;
       see below for other such features).

       In the definitions section (but not in the rules section),
       an unindented comment (i.e., a line beginning  with  "/*")
       is also copied verbatim to the output up to the next "*/".


</PRE>
<H2>PATTERNS</H2><PRE>
       The patterns in the input are written  using  an  extended
       set of regular expressions.  These are:

           x          match the character 'x'
           .          any character (byte) except newline
           [xyz]      a "character class"; in this case, the pattern
                        matches either an 'x', a 'y', or a 'z'
           [abj-oZ]   a "character class" with a range in it; matches
                        an 'a', a 'b', any letter from 'j' through 'o',
                        or a 'Z'
           [^A-Z]     a "negated character class", i.e., any character
                        but those in the class.  In this case, any
                        character EXCEPT an uppercase letter.
           [^A-Z\n]   any character EXCEPT an uppercase letter or
                        a newline
           r*         zero or more r's, where r is any regular expression
           r+         one or more r's
           r?         zero or one r's (that is, "an optional r")
           r{2,5}     anywhere from two to five r's
           r{2,}      two or more r's
           r{4}       exactly 4 r's
           {name}     the expansion of the "name" definition
                      (see above)
           "[xyz]\"foo"
                      the literal string: [xyz]"foo
           \X         if X is an 'a', 'b', 'f', 'n', 'r', 't', or 'v',
                        then the ANSI-C interpretation of \x.
                        Otherwise, a literal 'X' (used to escape
                        operators such as '*')
           \0         a NUL character (ASCII code 0)
           \123       the character with octal value 123
           \x2a       the character with hexadecimal value 2a
           (r)        match an r; parentheses are used to override
                        precedence (see below)


           rs         the regular expression r followed by the
                        cannot match correctly; see notes in the
                        Deficiencies / Bugs section below regarding
                        "dangerous trailing context".)
           ^r         an r, but only at the beginning of a line (i.e.,
                        which just starting to scan, or right after a
                        newline has been scanned).
           r$         an r, but only at the end of a line (i.e., just
                        before a newline).  Equivalent to "r/\n".

                      Note that flex's notion of "newline" is exactly
                      whatever the C compiler used to compile flex
                      interprets '\n' as; in particular, on some DOS
                      systems you must either filter out \r's in the
                      input yourself, or explicitly use r/\r\n for "r$".


           &lt;s&gt;r       an r, but only in start condition s (see
                        below for discussion of start conditions)
           &lt;s1,s2,s3&gt;r
                      same, but in any of start conditions s1,
                        s2, or s3
           &lt;*&gt;r       an r in any start condition, even an exclusive one.


           &lt;&lt;EOF&gt;&gt;    an end-of-file
           &lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt;
                      an end-of-file when in start condition s1 or s2

       Note that inside of a character class, all regular expres­
       sion operators lose their special  meaning  except  escape
       ('\') and the character class operators, '-', ']', and, at
       the beginning of the class, '^'.

       The regular expressions listed above are grouped according
       to  precedence, from highest precedence at the top to low­
       est at the bottom.   Those  grouped  together  have  equal
       precedence.  For example,

           foo|bar*

       is the same as

           (foo)|(ba(r*))

       since the '*' operator has higher precedence than concate­
       nation, and concatenation higher than  alternation  ('|').
       This  pattern therefore matches <I>either</I> the string "foo" <I>or</I>
       the string "ba" followed by zero-or-more  r's.   To  match
       "foo" or zero-or-more "bar"'s, use:

           foo|(bar)*

           [:cntrl:] [:digit:] [:graph:]
           [:lower:] [:print:] [:punct:]
           [:space:] [:upper:] [:xdigit:]

       These expressions all designate a set of characters equiv­
       alent to the corresponding standard C <B>isXXX</B> function.  For
       example,  <B>[:alnum:]</B>  designates those characters for which
       <B>isalnum()</B> returns true - i.e., any alphabetic or  numeric.
       Some  systems  don't  provide  <B>isblank(),</B>  so flex defines
       <B>[:blank:]</B> as a blank or a tab.

       For example,  the  following  character  classes  are  all
       equivalent:

           [[:alnum:]]
           [[:alpha:][:digit:]
           [[:alpha:]0-9]
           [a-zA-Z0-9]

       If  your  scanner  is case-insensitive (the <B>-i</B> flag), then
       <B>[:upper:]</B> and <B>[:lower:]</B> are equivalent to <B>[:alpha:].</B>

       Some notes on patterns:

       -      A negated character class such as the example "[^A-
              Z]"  above  <I>will</I> <I>match</I> <I>a</I> <I>newline</I> unless "\n" (or an
              equivalent escape sequence) is one of  the  charac­
              ters  explicitly  present  in the negated character
              class (e.g., "[^A-Z\n]").  This is unlike how  many
              other  regular expression tools treat negated char­
              acter classes, but unfortunately the  inconsistency
              is   historically  entrenched.   Matching  newlines
              means that a  pattern  like  [^"]*  can  match  the
              entire  input  unless  there's another quote in the
              input.

       -      A rule can have at most one  instance  of  trailing
              context  (the  '/'  operator  or the '$' operator).
              The start condition, '^',  and  "&lt;&lt;EOF&gt;&gt;"  patterns
              can  only occur at the beginning of a pattern, and,
              as well as with '/'  and  '$',  cannot  be  grouped
              inside  parentheses.  A '^' which does not occur at
              the beginning of a rule or a  '$'  which  does  not
              occur  at the end of a rule loses its special prop­
              erties and is treated as a normal character.

              The following are illegal:

                  foo/bar$
                  &lt;sc1&gt;foo&lt;sc2&gt;bar

              Note that  the  first  of  these,  can  be  written

              A similar trick will work for matching a foo  or  a
              bar-at-the-beginning-of-a-line.


</PRE>
<H2>HOW THE INPUT IS MATCHED</H2><PRE>
       When  the  generated scanner is run, it analyzes its input
       looking for strings which match any of its  patterns.   If
       it  finds  more  than one match, it takes the one matching
       the most text (for trailing context rules,  this  includes
       the  length of the trailing part, even though it will then
       be returned to the  input).   If  it  finds  two  or  more
       matches  of  the same length, the rule listed first in the
       <I>flex</I> input file is chosen.

       Once the match is determined, the  text  corresponding  to
       the  match  (called  the  <I>token)</I>  is made available in the
       global character pointer <B>yytext,</B> and  its  length  in  the
       global  integer  <B>yyleng.</B>   The <I>action</I> corresponding to the
       matched pattern is then executed (a more detailed descrip­
       tion  of actions follows), and then the remaining input is
       scanned for another match.

       If no match is found, then the <I>default</I> <I>rule</I>  is  executed:
       the  next character in the input is considered matched and
       copied to the standard output.  Thus, the  simplest  legal
       <I>flex</I> input is:

           %%

       which  generates  a  scanner  that simply copies its input
       (one character at a time) to its output.

       Note that <B>yytext</B> can be defined  in  two  different  ways:
       either  as  a  character  <I>pointer</I> or as a character <I>array.</I>
       You can control which definition <I>flex</I>  uses  by  including
       one  of  the  special directives <B>%pointer</B> or <B>%array</B> in the
       first (definitions)  section  of  your  flex  input.   The
       default is <B>%pointer,</B> unless you use the <B>-l</B> lex compatibil­
       ity option, in which case <B>yytext</B> will be  an  array.   The
       advantage  of using <B>%pointer</B> is substantially faster scan­
       ning and no  buffer  overflow  when  matching  very  large
       tokens (unless you run out of dynamic memory).  The disad­
       vantage is that you are restricted in how your actions can
       modify  <B>yytext</B>  (see  the  next section), and calls to the
       <B>unput()</B> function destroys the present contents of  <B>yytext,</B>
       which  can  be a considerable porting headache when moving
       between different <I>lex</I> versions.

       The advantage of <B>%array</B> is that you can then modify <B>yytext</B>
       to  your  heart's  content,  and  calls  to <B>unput()</B> do not
       destroy <B>yytext</B> (see  below).   Furthermore,  existing  <I>lex</I>
       programs sometimes access <B>yytext</B> externally using declara­
       token from the beginning,  so  matching  such  tokens  can
       prove slow.  <B>yytext</B> presently does <I>not</I> dynamically grow if
       a call to <B>unput()</B> results in too much  text  being  pushed
       back; instead, a run-time error results.

       Also  note  that  you  cannot  use <B>%array</B> with C++ scanner
       classes (the <B>c++</B> option; see below).


</PRE>
<H2>ACTIONS</H2><PRE>
       Each pattern in a rule has a corresponding  action,  which
       can be any arbitrary C statement.  The pattern ends at the
       first non-escaped whitespace character; the  remainder  of
       the line is its action.  If the action is empty, then when
       the pattern is matched the  input  token  is  simply  dis­
       carded.  For example, here is the specification for a pro­
       gram which deletes all occurrences of "zap  me"  from  its
       input:

           %%
           "zap me"

       (It  will  copy  all  other characters in the input to the
       output since they will be matched by the default rule.)

       Here is a program which  compresses  multiple  blanks  and
       tabs  down  to  a single blank, and throws away whitespace
       found at the end of a line:

           %%
           [ \t]+        putchar( ' ' );
           [ \t]+$       /* ignore this token */


       If the action contains a '{', then the action  spans  till
       the  balancing '}' is found, and the action may cross mul­
       tiple lines.  <I>flex</I> knows about C strings and comments  and
       won't  be  fooled  by  braces  found within them, but also
       allows actions to begin with  <B>%{</B>  and  will  consider  the
       action to be all the text up to the next <B>%}</B> (regardless of
       ordinary braces inside the action).

       An action consisting solely of a vertical bar ('|')  means
       "same  as the action for the next rule."  See below for an
       illustration.

       Actions can include arbitrary  C  code,  including  <B>return</B>
       statements  to  return  a value to whatever routine called
       <B>yylex().</B>  Each time <B>yylex()</B> is called  it  continues  pro­
       cessing tokens from where it last left off until it either
       reaches the end of the file or executes a return.

       Actions are free to modify <B>yytext</B> except  for  lengthening
       -      <B>BEGIN</B>  followed  by  the  name of a start condition
              places the scanner in the corresponding start  con­
              dition (see below).

       -      <B>REJECT</B>  directs  the  scanner  to proceed on to the
              "second best" rule which matched the  input  (or  a
              prefix  of  the  input).   The  rule  is  chosen as
              described above in "How the Input is Matched",  and
              <B>yytext</B>  and  <B>yyleng</B>  set  up appropriately.  It may
              either be one which matched as  much  text  as  the
              originally  chosen  rule but came later in the <I>flex</I>
              input file, or one which matched  less  text.   For
              example, the following will both count the words in
              the input and call the routine  special()  whenever
              "frob" is seen:

                          int word_count = 0;
                  %%

                  frob        special(); REJECT;
                  [^ \t\n]+   ++word_count;

              Without the <B>REJECT,</B> any "frob"'s in the input would
              not be counted as words, since the scanner normally
              executes  only  one  action  per  token.   Multiple
              <B>REJECT's</B> are allowed, each  one  finding  the  next
              best  choice  to  the  currently  active rule.  For
              example, when the following scanner scans the token
              "abcd", it will write "abcdabcaba" to the output:

                  %%
                  a        |
                  ab       |
                  abc      |
                  abcd     ECHO; REJECT;
                  .|\n     /* eat up any unmatched character */

              (The  first  three  rules share the fourth's action
              since they use the special '|' action.)  <B>REJECT</B>  is
              a  particularly expensive feature in terms of scan­
              ner performance; if it is used in <I>any</I> of the  scan­
              ner's  actions  it  will slow down <I>all</I> of the scan­
              ner's matching.  Furthermore, <B>REJECT</B> cannot be used
              with the <I>-Cf</I> or <I>-CF</I> options (see below).

              Note  also  that  unlike the other special actions,
              <B>REJECT</B> is a <I>branch;</I> code immediately  following  it
              in the action will <I>not</I> be executed.

       -      <B>yymore()</B>  tells  the  scanner that the next time it
              matches a rule, the corresponding token  should  be
              <I>appended</I>  onto  the  current value of <B>yytext</B> rather

       Two notes regarding  use  of  <B>yymore().</B>   First,  <B>yymore()</B>
       depends  on  the  value of <I>yyleng</I> correctly reflecting the
       size of the current token, so you must not  modify  <I>yyleng</I>
       if  you  are  using  <B>yymore().</B>   Second,  the  presence of
       <B>yymore()</B> in the scanner's action entails a  minor  perfor­
       mance penalty in the scanner's matching speed.

       -      <B>yyless(n)</B> returns all but the first <I>n</I> characters of
              the current token back to the input  stream,  where
              they  will  be rescanned when the scanner looks for
              the next match.  <B>yytext</B>  and  <B>yyleng</B>  are  adjusted
              appropriately  (e.g., <B>yyleng</B> will now be equal to <I>n</I>
              ).  For example, on the input "foobar" the  follow­
              ing will write out "foobarbar":

                  %%
                  foobar    ECHO; <B>yyless(3)</B>;
                  [a-z]+    ECHO;

              An  argument  of  0 to <B>yyless</B> will cause the entire
              current input string to be scanned  again.   Unless
              you've  changed  how  the scanner will subsequently
              process its input (using <B>BEGIN,</B> for example),  this
              will result in an endless loop.

       Note  that  <B>yyless</B>  is a macro and can only be used in the
       flex input file, not from other source files.

       -      <B>unput(c)</B> puts the character <I>c</I> back onto  the  input
              stream.   It  will  be  the next character scanned.
              The following action will take  the  current  token
              and  cause it to be rescanned enclosed in parenthe­
              ses.

                  {
                  int i;
                  /* Copy yytext because unput() trashes yytext */
                  char *yycopy = strdup( yytext );
                  unput( ')' );
                  for ( i = yyleng - 1; i &gt;= 0; --i )
                      unput( yycopy[i] );
                  unput( '(' );
                  free( yycopy );
                  }

              Note that since each <B>unput()</B> puts the given charac­
              ter  back  at  the  <I>beginning</I>  of the input stream,
              pushing back strings must be done back-to-front.

       An important potential problem when using <B>unput()</B> is  that
       if you are using <B>%pointer</B> (the default), a call to <B>unput()</B>
       <I>destroys</I> the contents of <I>yytext,</I> starting with its  right­
                  "/*"        {
                              register int c;

                              for ( ; ; )
                                  {
                                  while ( (c = input()) != '*' &amp;&amp;
                                          c != EOF )
                                      ;    /* eat up text of comment */

                                  if ( c == '*' )
                                      {
                                      while ( (c = input()) == '*' )
                                          ;
                                      if ( c == '/' )
                                          break;    /* found the end */
                                      }

                                  if ( c == EOF )
                                      {
                                      error( "EOF in comment" );
                                      break;
                                      }
                                  }
                              }

              (Note that if the scanner is  compiled  using  <B>C++,</B>
              then  <B>input()</B>  is instead referred to as <B>yyinput(),</B>
              in order to avoid a name clash with the <B>C++</B>  stream
              by the name of <I>input.)</I>

       -      <B>YY_FLUSH_BUFFER</B>   flushes  the  scanner's  internal
              buffer so that the next time the  scanner  attempts
              to  match  a token, it will first refill the buffer
              using <B>YY_INPUT</B> (see The Generated Scanner,  below).
              This  action  is a special case of the more general
              <B>yy_flush_buffer()</B> function, described below in  the
              section Multiple Input Buffers.

       -      <B>yyterminate()</B>  can  be  used  in  lieu  of a return
              statement in an action.  It terminates the  scanner
              and returns a 0 to the scanner's caller, indicating
              "all done".   By  default,  <B>yyterminate()</B>  is  also
              called when an end-of-file is encountered.  It is a
              macro and may be redefined.


</PRE>
<H2>THE GENERATED SCANNER</H2><PRE>
       The output of <I>flex</I> is the file  <B>lex.yy.c,</B>  which  contains
       the  scanning  routine <B>yylex(),</B> a number of tables used by
       it for matching tokens, and a number of auxiliary routines
       and macros.  By default, <B>yylex()</B> is declared as follows:

           int yylex()

       style/non-prototyped function declaration, you must termi­
       nate the definition with a semi-colon (;).

       Whenever <B>yylex()</B> is  called,  it  scans  tokens  from  the
       global input file <I>yyin</I> (which defaults to stdin).  It con­
       tinues until it either reaches an  end-of-file  (at  which
       point  it  returns the value 0) or one of its actions exe­
       cutes a <I>return</I> statement.

       If the scanner reaches an  end-of-file,  subsequent  calls
       are undefined unless either <I>yyin</I> is pointed at a new input
       file (in which case scanning continues from that file), or
       <B>yyrestart()</B>  is called.  <B>yyrestart()</B> takes one argument, a
       <B>FILE</B> <B>*</B> pointer  (which  can  be  nil,  if  you've  set  up
       <B>YY_INPUT</B>  to scan from a source other than <I>yyin),</I> and ini­
       tializes <I>yyin</I> for scanning from  that  file.   Essentially
       there  is  no  difference between just assigning <I>yyin</I> to a
       new input file or using <B>yyrestart()</B> to do so;  the  latter
       is  available  for compatibility with previous versions of
       <I>flex,</I> and because it can be used to switch input files  in
       the middle of scanning.  It can also be used to throw away
       the current input buffer, by calling it with  an  argument
       of <I>yyin;</I> but better is to use <B>YY_FLUSH_BUFFER</B> (see above).
       Note that <B>yyrestart()</B> does <I>not</I> reset the  start  condition
       to <B>INITIAL</B> (see Start Conditions, below).

       If <B>yylex()</B> stops scanning due to executing a <I>return</I> state­
       ment in one of the actions, the scanner may then be called
       again and it will resume scanning where it left off.

       By  default  (and for purposes of efficiency), the scanner
       uses block-reads rather than simple <I>getc()</I> calls  to  read
       characters from <I>yyin.</I>  The nature of how it gets its input
       can  be  controlled  by  defining  the   <B>YY_INPUT</B>   macro.
       YY_INPUT's           calling          sequence          is
       "YY_INPUT(buf,result,max_size)".  Its action is  to  place
       up  to  <I>max</I><B>_</B><I>size</I> characters in the character array <I>buf</I> and
       return in the integer variable <I>result</I> either the number of
       characters  read  or  the constant YY_NULL (0 on Unix sys­
       tems) to indicate EOF.  The default  YY_INPUT  reads  from
       the global file-pointer "yyin".

       A  sample  definition of YY_INPUT (in the definitions sec­
       tion of the input file):

           %{
           #define YY_INPUT(buf,result,max_size) \
               { \
               int c = getchar(); \
               result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
               }
           %}

       you  must  either  use <B>%option</B> <B>noyywrap</B> (in which case the
       scanner behaves as though <B>yywrap()</B>  returned  1),  or  you
       must  link  with <B>-lfl</B> to obtain the default version of the
       routine, which always returns 1.

       Three routines are available for scanning  from  in-memory
       buffers     rather     than    files:    <B>yy_scan_string(),</B>
       <B>yy_scan_bytes(),</B> and <B>yy_scan_buffer().</B>  See the discussion
       of them below in the section Multiple Input Buffers.

       The  scanner  writes  its  <B>ECHO</B> output to the <I>yyout</I> global
       (default, stdout), which may be redefined by the user sim­
       ply by assigning it to some other <B>FILE</B> pointer.


</PRE>
<H2>START CONDITIONS</H2><PRE>
       <I>flex</I>  provides  a  mechanism  for conditionally activating
       rules.  Any rule whose pattern  is  prefixed  with  "&lt;sc&gt;"
       will  only be active when the scanner is in the start con­
       dition named "sc".  For example,

           &lt;STRING&gt;[^"]*        { /* eat up the string body ... */
                       ...
                       }

       will be active only when the scanner is  in  the  "STRING"
       start condition, and

           &lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an escape ... */
                       ...
                       }

       will  be  active  only when the current start condition is
       either "INITIAL", "STRING", or "QUOTE".

       Start conditions are declared in the  definitions  (first)
       section of the input using unindented lines beginning with
       either <B>%s</B> or <B>%x</B> followed by a list of names.   The  former
       declares  <I>inclusive</I> start conditions, the latter <I>exclusive</I>
       start conditions.  A start condition  is  activated  using
       the  <B>BEGIN</B>  action.   Until  the next <B>BEGIN</B> action is exe­
       cuted, rules with the given start condition will be active
       and  rules  with  other start conditions will be inactive.
       If the start condition is <I>inclusive,</I> then  rules  with  no
       start  conditions  at  all  will also be active.  If it is
       <I>exclusive,</I> then <I>only</I> rules qualified with the start condi­
       tion  will  be  active.   A set of rules contingent on the
       same exclusive start condition describe a scanner which is
       independent  of  any of the other rules in the <I>flex</I> input.
       Because of this, exclusive start conditions make  it  easy
       to  specify  "mini-scanners"  which  scan  portions of the
       input that  are  syntactically  different  from  the  rest
       (e.g., comments).

           %x example
           %%

           &lt;example&gt;foo   do_something();

           &lt;INITIAL,example&gt;bar    something_else();

       Without the <B>&lt;INITIAL,example&gt;</B> qualifier, the  <I>bar</I>  pattern
       in  the  second example wouldn't be active (i.e., couldn't
       match) when in start condition <B>example.</B>  If we  just  used
       <B>&lt;example&gt;</B>  to  qualify  <I>bar,</I> though, then it would only be
       active in <B>example</B> and not in <B>INITIAL,</B> while in  the  first
       example  it's active in both, because in the first example
       the <B>example</B> startion condition is an <I>inclusive</I> <B>(%s)</B>  start
       condition.

       Also  note  that the special start-condition specifier <B>&lt;*&gt;</B>
       matches every start condition.  Thus,  the  above  example
       could also have been written;

           %x example
           %%

           &lt;example&gt;foo   do_something();

           &lt;*&gt;bar    something_else();


       The default rule (to <B>ECHO</B> any unmatched character) remains
       active in start conditions.  It is equivalent to:

           &lt;*&gt;.|\n     ECHO;


       <B>BEGIN(0)</B> returns to the  original  state  where  only  the
       rules with no start conditions are active.  This state can
       also be referred to as the start-condition  "INITIAL",  so
       <B>BEGIN(INITIAL)</B>  is equivalent to <B>BEGIN(0).</B>  (The parenthe­
       ses around the start condition name are not  required  but
       are considered good style.)

       <B>BEGIN</B>  actions  can  also be given as indented code at the
       beginning of the rules section.  For example, the  follow­
       ing  will  cause  the scanner to enter the "SPECIAL" start
       condition whenever <B>yylex()</B> is called and the global  vari­
       able <I>enter</I><B>_</B><I>special</I> is true:

                   int enter_special;

           %x SPECIAL
           %%

           %{
           #include &lt;math.h&gt;
           %}
           %s expect

           %%
           expect-floats        BEGIN(expect);

           &lt;expect&gt;[0-9]+"."[0-9]+      {
                       printf( "found a float, = %f\n",
                               atof( yytext ) );
                       }
           &lt;expect&gt;\n           {
                       /* that's the end of the line, so
                        * we need another "expect-number"
                        * before we'll recognize any more
                        * numbers
                        */
                       BEGIN(INITIAL);
                       }

           [0-9]+      {
                       printf( "found an integer, = %d\n",
                               atoi( yytext ) );
                       }

           "."         printf( "found a dot\n" );

       Here  is  a scanner which recognizes (and discards) C com­
       ments while maintaining a count of the current input line.

           %x comment
           %%
                   int line_num = 1;

           "/*"         BEGIN(comment);

           &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
           &lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
           &lt;comment&gt;\n             ++line_num;
           &lt;comment&gt;"*"+"/"        BEGIN(INITIAL);

       This  scanner  goes  to  a bit of trouble to match as much
       text  as  possible  with  each  rule.   In  general,  when
       attempting  to  write a high-speed scanner try to match as
       much possible in each rule, as it's a big win.

       Note that start-conditions names are really integer values
       and  can  be  stored  as  such.   Thus, the above could be
       extended in the following fashion:

                        BEGIN(comment);
                        }

           &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
           &lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
           &lt;comment&gt;\n             ++line_num;
           &lt;comment&gt;"*"+"/"        BEGIN(comment_caller);

       Furthermore, you can access the  current  start  condition
       using the integer-valued <B>YY_START</B> macro.  For example, the
       above assignments to <I>comment</I><B>_</B><I>caller</I> could instead be writ­
       ten

           comment_caller = YY_START;

       Flex provides <B>YYSTATE</B> as an alias for <B>YY_START</B> (since that
       is what's used by AT&amp;T <I>lex).</I>

       Note that start conditions do not  have  their  own  name-
       space;  %s's and %x's declare names in the same fashion as
       #define's.

       Finally, here's an example of how to match C-style  quoted
       strings   using   exclusive  start  conditions,  including
       expanded escape sequences (but not including checking  for
       a string that's too long):

           %x str

           %%
                   char string_buf[MAX_STR_CONST];
                   char *string_buf_ptr;


           \"      string_buf_ptr = string_buf; BEGIN(str);

           &lt;str&gt;\"        { /* saw closing quote - all done */
                   BEGIN(INITIAL);
                   *string_buf_ptr = '\0';
                   /* return string constant token type and
                    * value to parser
                    */
                   }

           &lt;str&gt;\n        {
                   /* error - unterminated string constant */
                   /* generate error message */
                   }

           &lt;str&gt;\\[0-7]{1,3} {
                   /* octal escape sequence */
                   int result;

           &lt;str&gt;\\n  *string_buf_ptr++ = '\n';
           &lt;str&gt;\\t  *string_buf_ptr++ = '\t';
           &lt;str&gt;\\r  *string_buf_ptr++ = '\r';
           &lt;str&gt;\\b  *string_buf_ptr++ = '\b';
           &lt;str&gt;\\f  *string_buf_ptr++ = '\f';

           &lt;str&gt;\\(.|\n)  *string_buf_ptr++ = yytext[1];

           &lt;str&gt;[^\\\n\"]+        {
                   char *yptr = yytext;

                   while ( *yptr )
                           *string_buf_ptr++ = *yptr++;
                   }


       Often,  such as in some of the examples above, you wind up
       writing a whole bunch of rules all preceded  by  the  same
       start  condition(s).   Flex makes this a little easier and
       cleaner by introducing a notion of start condition  <I>scope.</I>
       A start condition scope is begun with:

           &lt;SCs&gt;{

       where  <I>SCs</I>  is  a  list  of  one or more start conditions.
       Inside the start condition scope, every rule automatically
       has  the  prefix  <I>&lt;SCs&gt;</I>  applied  to it, until a <I>'}'</I> which
       matches the initial <I>'{'.</I>  So, for example,

           &lt;ESC&gt;{
               "\\n"   return '\n';
               "\\r"   return '\r';
               "\\f"   return '\f';
               "\\0"   return '\0';
           }

       is equivalent to:

           &lt;ESC&gt;"\\n"  return '\n';
           &lt;ESC&gt;"\\r"  return '\r';
           &lt;ESC&gt;"\\f"  return '\f';
           &lt;ESC&gt;"\\0"  return '\0';

       Start condition scopes may be nested.

       Three routines are available for  manipulating  stacks  of
       start conditions:

       <B>void</B> <B>yy_push_state(int</B> <B>new_state)</B>
              pushes  the current start condition onto the top of
              the start condition stack and switches to <I>new</I><B>_</B><I>state</I>

       To use start condition stacks, your scanner must include a
       <B>%option</B> <B>stack</B> directive (see Options below).


</PRE>
<H2>MULTIPLE INPUT BUFFERS</H2><PRE>
       Some  scanners  (such  as  those  which  support "include"
       files) require reading from  several  input  streams.   As
       <I>flex</I>  scanners  do a large amount of buffering, one cannot
       control where the next input will be read from  by  simply
       writing a <B>YY_INPUT</B> which is sensitive to the scanning con­
       text.  <B>YY_INPUT</B> is only called when  the  scanner  reaches
       the  end  of  its  buffer,  which may be a long time after
       scanning a statement such as an "include"  which  requires
       switching the input source.

       To  negotiate  these  sorts  of  problems, <I>flex</I> provides a
       mechanism for  creating  and  switching  between  multiple
       input buffers.  An input buffer is created by using:

           YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )

       which takes a <I>FILE</I> pointer and a size and creates a buffer
       associated with the given file and large  enough  to  hold
       <I>size</I>  characters  (when  in doubt, use <B>YY_BUF_SIZE</B> for the
       size).  It returns a  <B>YY_BUFFER_STATE</B>  handle,  which  may
       then  be  passed  to  other  routines  (see  below).   The
       <B>YY_BUFFER_STATE</B> type is a  pointer  to  an  opaque  <B>struct</B>
       <B>yy_buffer_state</B>  structure,  so  you may safely initialize
       YY_BUFFER_STATE variables to <B>((YY_BUFFER_STATE)</B> <B>0)</B> if  you
       wish,  and  also refer to the opaque structure in order to
       correctly declare input buffers in source files other than
       that  of  your scanner.  Note that the <I>FILE</I> pointer in the
       call to <B>yy_create_buffer</B> is only used as the value of <I>yyin</I>
       seen by <B>YY_INPUT;</B> if you redefine <B>YY_INPUT</B> so it no longer
       uses <I>yyin,</I> then you can safely pass a nil <I>FILE</I> pointer  to
       <B>yy_create_buffer.</B>   You select a particular buffer to scan
       from using:

           void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )

       switches the scanner's input buffer so  subsequent  tokens
       will      come     from     <I>new</I><B>_</B><I>buffer.</I>      Note     that
       <B>yy_switch_to_buffer()</B> may  be  used  by  yywrap()  to  set
       things up for continued scanning, instead of opening a new
       file and pointing <I>yyin</I> at it.  Note  also  that  switching
       input sources via either <B>yy_switch_to_buffer()</B> or <B>yywrap()</B>
       does <I>not</I> change the start condition.

           void yy_delete_buffer( YY_BUFFER_STATE buffer )

       is used to reclaim the storage associated with  a  buffer.
       (  <B>buffer</B> can be nil, in which case the routine does noth­
       <B>YY_BUFFER_STATE</B> handle to the current buffer.

       Here  is  an example of using these features for writing a
       scanner which expands include files (the  <B>&lt;&lt;EOF&gt;&gt;</B>  feature
       is discussed below):

           /* the "incl" state is used for picking up the name
            * of an include file
            */
           %x incl

           %{
           #define MAX_INCLUDE_DEPTH 10
           YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
           int include_stack_ptr = 0;
           %}

           %%
           include             BEGIN(incl);

           [a-z]+              ECHO;
           [^a-z\n]*\n?        ECHO;

           &lt;incl&gt;[ \t]*      /* eat the whitespace */
           &lt;incl&gt;[^ \t\n]+   { /* got the include file name */
                   if ( include_stack_ptr &gt;= MAX_INCLUDE_DEPTH )
                       {
                       fprintf( stderr, "Includes nested too deeply" );
                       exit( 1 );
                       }

                   include_stack[include_stack_ptr++] =
                       YY_CURRENT_BUFFER;

                   yyin = fopen( yytext, "r" );

                   if ( ! yyin )
                       error( ... );

                   yy_switch_to_buffer(
                       yy_create_buffer( yyin, YY_BUF_SIZE ) );

                   BEGIN(INITIAL);
                   }

           &lt;&lt;EOF&gt;&gt; {
                   if ( --include_stack_ptr &lt; 0 )
                       {
                       yyterminate();
                       }

                   else

       start scanning the string.

       <B>yy_scan_string(const</B> <B>char</B> <B>*str)</B>
              scans a NUL-terminated string.

       <B>yy_scan_bytes(const</B> <B>char</B> <B>*bytes,</B> <B>int</B> <B>len)</B>
              scans <I>len</I> bytes (including possibly NUL's) starting
              at location <I>bytes.</I>

       Note  that  both of these functions create and scan a <I>copy</I>
       of the string or bytes.  (This  may  be  desirable,  since
       <B>yylex()</B>  modifies  the  contents of the buffer it is scan­
       ning.)  You can avoid the copy by using:

       <B>yy_scan_buffer(char</B> <B>*base,</B> <B>yy_size_t</B> <B>size)</B>
              which scans in place the buffer starting  at  <I>base,</I>
              consisting  of  <I>size</I>  bytes,  the last two bytes of
              which <I>must</I> be  <B>YY_END_OF_BUFFER_CHAR</B>  (ASCII  NUL).
              These  last  two bytes are not scanned; thus, scan­
              ning  consists  of  <B>base[0]</B>  through  <B>base[size-2],</B>
              inclusive.

              If  you  fail  to set up <I>base</I> in this manner (i.e.,
              forget the final two <B>YY_END_OF_BUFFER_CHAR</B>  bytes),
              then <B>yy_scan_buffer()</B> returns a nil pointer instead
              of creating a new input buffer.

              The type <B>yy_size_t</B> is an integral type to which you
              can  cast an integer expression reflecting the size
              of the buffer.


</PRE>
<H2>END-OF-FILE RULES</H2><PRE>
       The special rule "&lt;&lt;EOF&gt;&gt;" indicates actions which are  to
       be  taken  when an end-of-file is encountered and yywrap()
       returns non-zero (i.e., indicates no further files to pro­
       cess).   The  action  must  finish  by  doing  one of four
       things:

       -      assigning <I>yyin</I> to a new  input  file  (in  previous
              versions  of  flex,  after doing the assignment you
              had to call the special action <B>YY_NEW_FILE;</B> this is
              no longer necessary);

       -      executing a <I>return</I> statement;

       -      executing the special <B>yyterminate()</B> action;

       -      or,    switching    to    a    new   buffer   using
              <B>yy_switch_to_buffer()</B>  as  shown  in  the   example
              above.

       &lt;&lt;EOF&gt;&gt;  rules  may  not be used with other patterns; they

           ...other rules for dealing with quotes...

           &lt;quote&gt;&lt;&lt;EOF&gt;&gt;   {
                    error( "unterminated quote" );
                    yyterminate();
                    }
           &lt;&lt;EOF&gt;&gt;  {
                    if ( *++filelist )
                        yyin = fopen( *filelist, "r" );
                    else
                       yyterminate();
                    }



</PRE>
<H2>MISCELLANEOUS MACROS</H2><PRE>
       The  macro  <B>YY_USER_ACTION</B>  can  be  defined to provide an
       action which is  always  executed  prior  to  the  matched
       rule's action.  For example, it could be #define'd to call
       a  routine  to  convert  yytext   to   lower-case.    When
       <B>YY_USER_ACTION</B>  is  invoked, the variable <I>yy</I><B>_</B><I>act</I> gives the
       number of the matched rule (rules  are  numbered  starting
       with  1).   Suppose  you want to profile how often each of
       your rules is matched.  The following would do the trick:

           #define YY_USER_ACTION ++ctr[yy_act]

       where <I>ctr</I> is an array to hold the counts for the different
       rules.   Note  that the macro <B>YY_NUM_RULES</B> gives the total
       number of rules (including the default rule, even  if  you
       use <B>-s),</B> so a correct declaration for <I>ctr</I> is:

           int ctr[YY_NUM_RULES];


       The macro <B>YY_USER_INIT</B> may be defined to provide an action
       which is always executed before the first scan (and before
       the  scanner's  internal  initializations  are done).  For
       example, it could be used to call a routine to read  in  a
       data table or open a logging file.

       The  macro  <B>yy_set_interactive(is_interactive)</B> can be used
       to control whether the current buffer is considered <I>inter­</I>
       <I>active.</I>   An  interactive buffer is processed more slowly,
       but must be used when the scanner's input source is indeed
       interactive  to  avoid  problems  due  to  waiting to fill
       buffers (see the discussion of the <B>-I</B> flag below).  A non-
       zero  value  in  the  macro invocation marks the buffer as
       interactive, a zero value as non-interactive.   Note  that
       use  of this macro overrides <B>%option</B> <B>always-interactive</B> or
       <B>%option</B>    <B>never-interactive</B>    (see    Options    below).
       <B>yy_set_interactive()</B> must be invoked prior to beginning to
       which may be  redefined.   By  default,  it  is  simply  a
       "break", to separate each rule's action from the following
       rule's.  Redefining  <B>YY_BREAK</B>  allows,  for  example,  C++
       users  to #define YY_BREAK to do nothing (while being very
       careful  that  every  rule  ends  with  a  "break"  or   a
       "return"!)  to  avoid suffering from unreachable statement
       warnings where because a rule's action ends with "return",
       the <B>YY_BREAK</B> is inaccessible.


</PRE>
<H2>VALUES AVAILABLE TO THE USER</H2><PRE>
       This  section  summarizes  the various values available to
       the user in the rule actions.

       -      <B>char</B> <B>*yytext</B> holds the text of the  current  token.
              It  may  be modified but not lengthened (you cannot
              append characters to the end).

              If the special  directive  <B>%array</B>  appears  in  the
              first  section  of  the  scanner  description, then
              <B>yytext</B> is  instead  declared  <B>char</B>  <B>yytext[YYLMAX],</B>
              where  <B>YYLMAX</B>  is  a  macro definition that you can
              redefine in the first section if you don't like the
              default   value   (generally  8KB).   Using  <B>%array</B>
              results in somewhat slower scanners, but the  value
              of  <B>yytext</B>  becomes  immune to calls to <I>input()</I> and
              <I>unput(),</I> which potentially destroy its  value  when
              <B>yytext</B>  is  a  character  pointer.  The opposite of
              <B>%array</B> is <B>%pointer,</B> which is the default.

              You cannot use <B>%array</B> when generating  C++  scanner
              classes (the <B>-+</B> flag).

       -      <B>int</B> <B>yyleng</B> holds the length of the current token.

       -      <B>FILE</B>  <B>*yyin</B> is the file which by default <I>flex</I> reads
              from.  It may be redefined but doing so only  makes
              sense  before  scanning  begins or after an EOF has
              been encountered.  Changing  it  in  the  midst  of
              scanning  will  have  unexpected results since <I>flex</I>
              buffers its input; use <B>yyrestart()</B>  instead.   Once
              scanning terminates because an end-of-file has been
              seen, you can assign <I>yyin</I> at the new input file and
              then call the scanner again to continue scanning.

       -      <B>void</B>  <B>yyrestart(</B>  <B>FILE</B> <B>*new_file</B> <B>)</B> may be called to
              point <I>yyin</I> at the new input file.  The  switch-over
              to  the  new  file  is  immediate  (any  previously
              buffered-up input  is  lost).   Note  that  calling
              <B>yyrestart()</B>  with  <I>yyin</I>  as an argument thus throws
              away the current input buffer and  continues  scan­
              ning the same input file.

       named <B>yylex()</B> to find the next input token.   The  routine
       is  supposed  to return the type of the next token as well
       as putting any associated value in the global <B>yylval.</B>   To
       use <I>flex</I> with <I>yacc,</I> one specifies the <B>-d</B> option to <I>yacc</I> to
       instruct it to generate the file <B>y.tab.h</B> containing  defi­
       nitions  of  all  the <B>%tokens</B> appearing in the <I>yacc</I> input.
       This file is then included in the <I>flex</I> scanner.  For exam­
       ple,  if  one  of  the tokens is "TOK_NUMBER", part of the
       scanner might look like:

           %{
           #include "y.tab.h"
           %}

           %%

           [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;



</PRE>
<H2>OPTIONS</H2><PRE>
       <I>flex</I> has the following options:

       <B>-b</B>     Generate  backing-up  information  to   <I>lex.backup.</I>
              This  is  a  list  of  scanner states which require
              backing up and the input characters on  which  they
              do  so.   By adding rules one can remove backing-up
              states.  If <I>all</I> backing-up  states  are  eliminated
              and  <B>-Cf</B> or <B>-CF</B> is used, the generated scanner will
              run faster (see the <B>-p</B> flag).  Only users who  wish
              to  squeeze  every last cycle out of their scanners
              need worry about this option.  (See the section  on
              Performance Considerations below.)

       <B>-c</B>     is  a  do-nothing,  deprecated  option included for
              POSIX compliance.

       <B>-d</B>     makes the generated  scanner  run  in  <I>debug</I>  mode.
              Whenever  a  pattern  is  recognized and the global
              <B>yy_flex_debug</B> is non-zero (which is  the  default),
              the  scanner  will  write  to  <I>stderr</I> a line of the
              form:

                  --accepting rule at line 53 ("the matched text")

              The line number refers to the location of the  rule
              in  the  file  defining the scanner (i.e., the file
              that was fed to flex).  Messages are also generated
              when  the  scanner  backs  up,  accepts the default
              rule, reaches the  end  of  its  input  buffer  (or
              encounters  a  NUL; at this point, the two look the
              same as far as the scanner's concerned), or reaches
              an end-of-file.
              text given in <I>yytext</I> will have the  preserved  case
              (i.e., it will not be folded).

       <B>-l</B>     turns  on  maximum  compatibility with the original
              AT&amp;T <I>lex</I> implementation.  Note that this  does  not
              mean  <I>full</I> compatibility.  Use of this option costs
              a considerable amount of performance, and it cannot
              be  used  with the <B>-+,</B> <B>-f,</B> <B>-F,</B> <B>-Cf,</B> or <B>-CF</B> options.
              For details on the compatibilities it provides, see
              the  section "Incompatibilities With Lex And POSIX"
              below.   This  option  also  results  in  the  name
              <B>YY_FLEX_LEX_COMPAT</B> being #define'd in the generated
              scanner.

       <B>-n</B>     is another do-nothing, deprecated  option  included
              only for POSIX compliance.

       <B>-p</B>     generates  a  performance  report  to  stderr.  The
              report consists of comments regarding  features  of
              the <I>flex</I> input file which will cause a serious loss
              of performance in the resulting  scanner.   If  you
              give  the  flag  twice,  you will also get comments
              regarding features that lead to  minor  performance
              losses.

              Note  that the use of <B>REJECT,</B> <B>%option</B> <B>yylineno,</B> and
              variable trailing context (see the  Deficiencies  /
              Bugs  section  below) entails a substantial perfor­
              mance penalty; use of <I>yymore(),</I> the <B>^</B> operator, and
              the <B>-I</B> flag entail minor performance penalties.

       <B>-s</B>     causes  the  <I>default</I>  <I>rule</I>  (that unmatched scanner
              input is echoed to <I>stdout)</I> to  be  suppressed.   If
              the  scanner  encounters  input that does not match
              any of its rules, it aborts with  an  error.   This
              option  is  useful for finding holes in a scanner's
              rule set.

       <B>-t</B>     instructs <I>flex</I> to write the scanner it generates to
              standard output instead of <B>lex.yy.c.</B>

       <B>-v</B>     specifies  that  <I>flex</I> should write to <I>stderr</I> a sum­
              mary of statistics regarding the scanner it  gener­
              ates.   Most  of  the statistics are meaningless to
              the casual <I>flex</I> user, but the first line identifies
              the  version  of <I>flex</I> (same as reported by <B>-V),</B> and
              the next line the flags used  when  generating  the
              scanner, including those that are on by default.

       <B>-w</B>     suppresses warning messages.

       <B>-B</B>     instructs  <I>flex</I>  to  generate  a <I>batch</I> scanner, the
              larger).  In general, if the pattern  set  contains
              both "keywords" and a catch-all, "identifier" rule,
              such as in the set:

                  "case"    return TOK_CASE;
                  "switch"  return TOK_SWITCH;
                  ...
                  "default" return TOK_DEFAULT;
                  [a-z]+    return TOK_ID;

              then you're better off using the full table  repre­
              sentation.   If  only the "identifier" rule is pre­
              sent and you then use a hash table or some such  to
              detect the keywords, you're better off using <B>-F.</B>

              This  option is equivalent to <B>-CFr</B> (see below).  It
              cannot be used with <B>-+.</B>

       <B>-I</B>     instructs <I>flex</I> to generate an <I>interactive</I>  scanner.
              An interactive scanner is one that only looks ahead
              to decide what token has been matched if  it  abso­
              lutely  must.  It turns out that always looking one
              extra character ahead,  even  if  the  scanner  has
              already  seen  enough text to disambiguate the cur­
              rent token, is a bit faster than only looking ahead
              when  necessary.   But  scanners  that  always look
              ahead give dreadful  interactive  performance;  for
              example,  when  a  user  types a newline, it is not
              recognized as a  newline  token  until  they  enter
              <I>another</I>  token, which often means typing in another
              whole line.

              <I>Flex</I> scanners default to <I>interactive</I> unless you use
              the  <B>-Cf</B>  or  <B>-CF</B>  table-compression  options  (see
              below).  That's because if you're looking for high-
              performance  you  should  be  using  one  of  these
              options, so  if  you  didn't,  <I>flex</I>  assumes  you'd
              rather  trade off a bit of run-time performance for
              intuitive interactive behavior.  Note also that you
              <I>cannot</I>  use  <B>-I</B>  in  conjunction  with  <B>-Cf</B> or <B>-CF.</B>
              Thus, this option is not really needed; it is on by
              default for all those cases in which it is allowed.

              You can force a scanner to <I>not</I>  be  interactive  by
              using <B>-B</B> (see above).

       <B>-L</B>     instructs  <I>flex</I>  not  to generate <B>#line</B> directives.
              Without this option,  <I>flex</I>  peppers  the  generated
              scanner  with #line directives so error messages in
              the actions will be correctly located with  respect
              to  either  the  original  <I>flex</I>  input file (if the
              errors are due to  code  in  the  input  file),  or
              one  which  can only recognized 7-bit characters in
              its input.  The advantage of using <B>-7</B> is  that  the
              scanner's  tables  can  be  up  to half the size of
              those generated using the <B>-8</B>  option  (see  below).
              The  disadvantage  is that such scanners often hang
              or crash if their input contains an  8-bit  charac­
              ter.

              Note,  however, that unless you generate your scan­
              ner using the <B>-Cf</B> or <B>-CF</B> table compression options,
              use  of  <B>-7</B>  will save only a small amount of table
              space, and  make  your  scanner  considerably  less
              portable.   <I>Flex's</I>  default behavior is to generate
              an 8-bit scanner unless you use the <B>-Cf</B> or <B>-CF,</B>  in
              which  case <I>flex</I> defaults to generating 7-bit scan­
              ners unless your site was always configured to gen­
              erate  8-bit  scanners  (as  will often be the case
              with non-USA sites).  You  can  tell  whether  flex
              generated a 7-bit or an 8-bit scanner by inspecting
              the flag summary in  the  <B>-v</B>  output  as  described
              above.

              Note that if you use <B>-Cfe</B> or <B>-CFe</B> (those table com­
              pression  options,  but  also   using   equivalence
              classes   as   discussed  see  below),  flex  still
              defaults to generating an 8-bit scanner, since usu­
              ally  with  these  compression  options  full 8-bit
              tables are  not  much  more  expensive  than  7-bit
              tables.

       <B>-8</B>     instructs  <I>flex</I> to generate an 8-bit scanner, i.e.,
              one which can  recognize  8-bit  characters.   This
              flag  is  only  needed for scanners generated using
              <B>-Cf</B> or <B>-CF,</B> as otherwise flex defaults to  generat­
              ing an 8-bit scanner anyway.

              See  the  discussion of <B>-7</B> above for flex's default
              behavior and the tradeoffs between 7-bit and  8-bit
              scanners.

       <B>-+</B>     specifies  that  you  want  flex  to generate a C++
              scanner class.  See the section on  Generating  C++
              Scanners below for details.

       <B>-C[aefFmr]</B>
              controls  the degree of table compression and, more
              generally, trade-offs between  small  scanners  and
              fast scanners.

              <B>-Ca</B>  ("align")  instructs  flex to trade off larger
              tables in the generated scanner for faster  perfor­
              mance because the elements of the tables are better
              cally a factor of 2-5) and are pretty cheap perfor­
              mance-wise   (one   array   look-up  per  character
              scanned).

              <B>-Cf</B> specifies that the <I>full</I> scanner  tables  should
              be  generated - <I>flex</I> should not compress the tables
              by taking advantages of  similar  transition  func­
              tions for different states.

              <B>-CF</B>  specifies that the alternate fast scanner rep­
              resentation (described above  under  the  <B>-F</B>  flag)
              should  be  used.   This option cannot be used with
              <B>-+.</B>

              <B>-Cm</B>  directs  <I>flex</I>  to  construct  <I>meta-equivalence</I>
              <I>classes,</I>  which are sets of equivalence classes (or
              characters, if equivalence classes  are  not  being
              used) that are commonly used together.  Meta-equiv­
              alence classes are often a big win when using  com­
              pressed  tables,  but  they have a moderate perfor­
              mance impact (one or two "if" tests and  one  array
              look-up per character scanned).

              <B>-Cr</B>  causes  the generated scanner to <I>bypass</I> use of
              the  standard  I/O  library  (stdio)   for   input.
              Instead  of  calling <B>fread()</B> or <B>getc(),</B> the scanner
              will use the <B>read()</B> system  call,  resulting  in  a
              performance  gain  which varies from system to sys­
              tem, but in general is probably  negligible  unless
              you are also using <B>-Cf</B> or <B>-CF.</B>  Using <B>-Cr</B> can cause
              strange behavior if, for  example,  you  read  from
              <I>yyin</I>  using  stdio  prior  to  calling  the scanner
              (because the scanner will miss whatever  text  your
              previous reads left in the stdio input buffer).

              <B>-Cr</B>  has  no effect if you define <B>YY_INPUT</B> (see The
              Generated Scanner above).

              A lone <B>-C</B> specifies that the scanner tables  should
              be  compressed  but neither equivalence classes nor
              meta-equivalence classes should be used.

              The options <B>-Cf</B> or <B>-CF</B> and <B>-Cm</B> do  not  make  sense
              together - there is no opportunity for meta-equiva­
              lence classes if the table is not being compressed.
              Otherwise  the options may be freely mixed, and are
              cumulative.

              The default setting is <B>-Cem,</B> which  specifies  that
              <I>flex</I>  should generate equivalence classes and meta-
              equivalence classes.   This  setting  provides  the
              highest degree of table compression.  You can trade
              usually generated and  compiled  the  quickest,  so
              during development you will usually want to use the
              default, maximal compression.

              <B>-Cfe</B> is often a good compromise between  speed  and
              size for production scanners.

       <B>-ooutput</B>
              directs  flex to write the scanner to the file <B>out­</B>
              <B>put</B> instead of <B>lex.yy.c.</B>  If you  combine  <B>-o</B>  with
              the  <B>-t</B> option, then the scanner is written to <I>std­</I>
              <I>out</I> but its <B>#line</B> directives  (see  the  <B>-L</B>  option
              above) refer to the file <B>output.</B>

       <B>-Pprefix</B>
              changes  the default <I>yy</I> prefix used by <I>flex</I> for all
              globally-visible variable  and  function  names  to
              instead  be <I>prefix.</I>  For example, <B>-Pfoo</B> changes the
              name of <B>yytext</B> to <B>footext.</B>   It  also  changes  the
              name  of  the  default output file from <B>lex.yy.c</B> to
              <B>lex.foo.c.</B>  Here are all of the names affected:

                  yy_create_buffer
                  yy_delete_buffer
                  yy_flex_debug
                  yy_init_buffer
                  yy_flush_buffer
                  yy_load_buffer_state
                  yy_switch_to_buffer
                  yyin
                  yyleng
                  yylex
                  yylineno
                  yyout
                  yyrestart
                  yytext
                  yywrap

              (If you are using a C++ scanner, then  only  <B>yywrap</B>
              and <B>yyFlexLexer</B> are affected.)  Within your scanner
              itself, you can still refer to the global variables
              and  functions  using either version of their name;
              but externally, they have the modified name.

              This option lets you easily link together  multiple
              <I>flex</I>  programs  into  the  same  executable.  Note,
              though,  that  using  this  option   also   renames
              <B>yywrap(),</B>  so  you now <I>must</I> either provide your own
              (appropriately-named) version of  the  routine  for
              your  scanner,  or use <B>%option</B> <B>noyywrap,</B> as linking
              with  <B>-lfl</B>  no  longer  provides  one  for  you  by
              default.

       Most options are given simply as  names,  optionally  pre­
       ceded by the word "no" (with no intervening whitespace) to
       negate their meaning.  A number  are  equivalent  to  flex
       flags or their negation:

           7bit            -7 option
           8bit            -8 option
           align           -Ca option
           backup          -b option
           batch           -B option
           c++             -+ option

           caseful or
           case-sensitive  opposite of -i (default)

           case-insensitive or
           caseless        -i option

           debug           -d option
           default         opposite of -s option
           ecs             -Ce option
           fast            -F option
           full            -f option
           interactive     -I option
           lex-compat      -l option
           meta-ecs        -Cm option
           perf-report     -p option
           read            -Cr option
           stdout          -t option
           verbose         -v option
           warn            opposite of -w option
                           (use "%option nowarn" for -w)

           array           equivalent to "%array"
           pointer         equivalent to "%pointer" (default)

       Some <B>%option's</B> provide features otherwise not available:

       <B>always-interactive</B>
              instructs  flex  to generate a scanner which always
              considers its input  "interactive".   Normally,  on
              each  new  input file the scanner calls <B>isatty()</B> in
              an attempt to determine whether the scanner's input
              source  is  interactive  and  thus should be read a
              character at a time.  When  this  option  is  used,
              however, then no such call is made.

       <B>main</B>   directs  flex  to  provide a default <B>main()</B> program
              for the scanner, which simply calls <B>yylex().</B>   This
              option implies <B>noyywrap</B> (see below).

              C,  which  does  not require <I>stdin</I> and <I>stdout</I> to be
              compile-time constant.

       <B>yylineno</B>
              directs <I>flex</I> to generate a scanner  that  maintains
              the  number of the current line read from its input
              in the global variable <B>yylineno.</B>   This  option  is
              implied by <B>%option</B> <B>lex-compat.</B>

       <B>yywrap</B> if  unset (i.e., <B>%option</B> <B>noyywrap),</B> makes the scan­
              ner not call <B>yywrap()</B> upon an end-of-file, but sim­
              ply  assume  that  there  are no more files to scan
              (until the user points <I>yyin</I> at a new file and calls
              <B>yylex()</B> again).

       <I>flex</I>  scans your rule actions to determine whether you use
       the <B>REJECT</B> or <B>yymore()</B> features.  The  <B>reject</B>  and  <B>yymore</B>
       options  are  available  to  override  its  decision as to
       whether you use the options, either by setting them (e.g.,
       <B>%option</B> <B>reject)</B> to indicate the feature is indeed used, or
       unsetting them to indicate it actually is not used  (e.g.,
       <B>%option</B> <B>noyymore).</B>

       Three  options  take  string-delimited values, offset with
       '=':

           %option outfile="ABC"

       is equivalent to <B>-oABC,</B> and

           %option prefix="XYZ"

       is equivalent to <B>-PXYZ.</B>  Finally,

           %option yyclass="foo"

       only applies when generating a C++ scanner (  <B>-+</B>  option).
       It informs <I>flex</I> that you have derived <B>foo</B> as a subclass of
       <B>yyFlexLexer,</B> so <I>flex</I> will place your actions in the member
       function <B>foo::yylex()</B> instead of <B>yyFlexLexer::yylex().</B>  It
       also generates a <B>yyFlexLexer::yylex()</B> member function that
       emits  a  run-time  error (by invoking <B>yyFlexLexer::Lexer­</B>
       <B>Error())</B> if called.  See Generating C++  Scanners,  below,
       for additional information.

       A  number  of  options  are available for lint purists who
       want to suppress the appearance of  unneeded  routines  in
       the  generated  scanner.   Each of the following, if unset
       (e.g., <B>%option</B> <B>nounput</B> ),  results  in  the  corresponding
       routine not appearing in the generated scanner:

           input, unput
           REJECT
           %option yylineno
           arbitrary trailing context

           pattern sets that require backing up
           %array
           %option interactive
           %option always-interactive

           '^' beginning-of-line operator
           yymore()

       with  the  first  three  all being quite expensive and the
       last two being quite cheap.  Note  also  that  <B>unput()</B>  is
       implemented  as a routine call that potentially does quite
       a bit of work, while <B>yyless()</B> is a quite-cheap  macro;  so
       if  just  putting  back  some excess text you scanned, use
       <B>yyless().</B>

       <B>REJECT</B> should be avoided at all costs when performance  is
       important.  It is a particularly expensive option.

       Getting  rid  of  backing  up is messy and often may be an
       enormous amount of work for  a  complicated  scanner.   In
       principal,  one  begins by using the <B>-b</B> flag to generate a
       <I>lex.backup</I> file.  For example, on the input

           %%
           foo        return TOK_KEYWORD;
           foobar     return TOK_KEYWORD;

       the file looks like:

           State #6 is non-accepting -
            associated rule line numbers:
                  2       3
            out-transitions: [ o ]
            jam-transitions: EOF [ \001-n  p-\177 ]

           State #8 is non-accepting -
            associated rule line numbers:
                  3
            out-transitions: [ a ]
            jam-transitions: EOF [ \001-`  b-\177 ]

           State #9 is non-accepting -
            associated rule line numbers:
                  3
            out-transitions: [ r ]
            jam-transitions: EOF [ \001-q  s-\177 ]

           Compressed tables always back up.

       The comment regarding State #8 indicates there's a problem
       when  "foob"  has  been scanned.  Indeed, on any character
       other than an 'a', the scanner will have  to  back  up  to
       accept  "foo".   Similarly,  the comment for State #9 con­
       cerns when "fooba" has been scanned and an  'r'  does  not
       follow.

       The  final  comment reminds us that there's no point going
       to all the trouble of removing backing up from  the  rules
       unless  we're  using  <B>-Cf</B> or <B>-CF,</B> since there's no perfor­
       mance gain doing so with compressed scanners.

       The way to remove the backing up is to add "error" rules:

           %%
           foo         return TOK_KEYWORD;
           foobar      return TOK_KEYWORD;

           fooba       |
           foob        |
           fo          {
                       /* false alarm, not really a keyword */
                       return TOK_ID;
                       }


       Eliminating backing up among a list of keywords  can  also
       be done using a "catch-all" rule:

           %%
           foo         return TOK_KEYWORD;
           foobar      return TOK_KEYWORD;

           [a-z]+      return TOK_ID;

       This is usually the best solution when appropriate.

       Backing  up  messages tend to cascade.  With a complicated
       set of rules it's not uncommon to  get  hundreds  of  mes­
       sages.   If  one  can decipher them, though, it often only
       takes a dozen or so rules  to  eliminate  the  backing  up
       (though it's easy to make a mistake and have an error rule
       accidentally match a valid token.  A possible future  <I>flex</I>
       feature  will  be  to automatically add rules to eliminate
       backing up).

       It's important to keep in mind that you gain the  benefits
       of  eliminating  backing  up  only  if you eliminate <I>every</I>
       instance of backing up.  Leaving just one means  you  gain
       nothing.

       or as

           %%
           mouse|rat/cat         run();
           mouse|rat/dog         run();

       Note that here the special '|' action does <I>not</I> provide any
       savings,  and can even make things worse (see Deficiencies
       / Bugs below).

       Another area where the user can increase a scanner's  per­
       formance  (and one that's easier to implement) arises from
       the fact that the longer the tokens  matched,  the  faster
       the  scanner  will  run.  This is because with long tokens
       the processing of most input characters takes place in the
       (short) inner scanning loop, and does not often have to go
       through the additional work of  setting  up  the  scanning
       environment  (e.g.,  <B>yytext)</B>  for  the action.  Recall the
       scanner for C comments:

           %x comment
           %%
                   int line_num = 1;

           "/*"         BEGIN(comment);

           &lt;comment&gt;[^*\n]*
           &lt;comment&gt;"*"+[^*/\n]*
           &lt;comment&gt;\n             ++line_num;
           &lt;comment&gt;"*"+"/"        BEGIN(INITIAL);

       This could be sped up by writing it as:

           %x comment
           %%
                   int line_num = 1;

           "/*"         BEGIN(comment);

           &lt;comment&gt;[^*\n]*
           &lt;comment&gt;[^*\n]*\n      ++line_num;
           &lt;comment&gt;"*"+[^*/\n]*
           &lt;comment&gt;"*"+[^*/\n]*\n ++line_num;
           &lt;comment&gt;"*"+"/"        BEGIN(INITIAL);

       Now instead of each newline requiring  the  processing  of
       another  action, recognizing the newlines is "distributed"
       over the other rules to keep the matched text as  long  as
       possible.   Note  that <I>adding</I> rules does <I>not</I> slow down the
       scanner!  The speed of the scanner is independent  of  the
       number of rules or (modulo the considerations given at the
       beginning of this section) how complicated the  rules  are
           while    /* it's a keyword */

           .|\n     /* it's not a keyword */

       To  eliminate  the  back-tracking,  introduce  a catch-all
       rule:

           %%
           asm      |
           auto     |
           break    |
           ... etc ...
           volatile |
           while    /* it's a keyword */

           [a-z]+   |
           .|\n     /* it's not a keyword */

       Now, if it's guaranteed that there's exactly one word  per
       line,  then we can reduce the total number of matches by a
       half by merging in the recognition of newlines  with  that
       of the other tokens:

           %%
           asm\n    |
           auto\n   |
           break\n  |
           ... etc ...
           volatile\n |
           while\n  /* it's a keyword */

           [a-z]+\n |
           .|\n     /* it's not a keyword */

       One  has  to  be careful here, as we have now reintroduced
       backing up into the scanner.  In particular, while <I>we</I> know
       that  there  will  never  be  any  characters in the input
       stream other than letters or newlines, <I>flex</I>  can't  figure
       this out, and it will plan for possibly needing to back up
       when it has scanned a token like "auto" and then the  next
       character  is  something other than a newline or a letter.
       Previously it would then just match the "auto" rule and be
       done, but now it has no "auto" rule, only a "auto\n" rule.
       To eliminate the  possibility  of  backing  up,  we  could
       either duplicate all rules but without final newlines, or,
       since we never expect  to  encounter  such  an  input  and
       therefore  don't how it's classified, we can introduce one
       more catch-all rule, this one which doesn't include a new­
       line:

           %%
           asm\n    |

       larly  when a token contains multiple NUL's.  It's best to
       write rules which match <I>short</I>  amounts  of  text  if  it's
       anticipated that the text will often include NUL's.

       Another  final  note  regarding  performance: as mentioned
       above in the section How the Input is Matched, dynamically
       resizing  <B>yytext</B> to accommodate huge tokens is a slow pro­
       cess because it presently requires that the  (huge)  token
       be  rescanned  from the beginning.  Thus if performance is
       vital, you should attempt to match "large"  quantities  of
       text  but  not "huge" quantities, where the cutoff between
       the two is at about 8K characters/token.


</PRE>
<H2>GENERATING C++ SCANNERS</H2><PRE>
       <I>flex</I> provides two different ways to generate scanners  for
       use  with C++.  The first way is to simply compile a scan­
       ner generated by <I>flex</I> using a C++ compiler instead of a  C
       compiler.   You  should  not  encounter  any  compilations
       errors (please report any you find to  the  email  address
       given  in the Author section below).  You can then use C++
       code in your rule actions instead of C  code.   Note  that
       the  default  input  source for your scanner remains <I>yyin,</I>
       and default echoing is still done to <I>yyout.</I>  Both of these
       remain <I>FILE</I> <I>*</I> variables and not C++ <I>streams.</I>

       You  can  also  use  <I>flex</I> to generate a C++ scanner class,
       using the <B>-+</B> option (or, equivalently, <B>%option</B> <B>c++),</B> which
       is  automatically  specified  if the name of the flex exe­
       cutable ends in a '+', such as <I>flex++.</I>   When  using  this
       option,  flex  defaults  to  generating the scanner to the
       file <B>lex.yy.cc</B> instead of <B>lex.yy.c.</B>  The generated scanner
       includes  the  header  file <I>FlexLexer.h,</I> which defines the
       interface to two C++ classes.

       The first class,  <B>FlexLexer,</B>  provides  an  abstract  base
       class  defining  the  general scanner class interface.  It
       provides the following member functions:

       <B>const</B> <B>char*</B> <B>YYText()</B>
              returns the  text  of  the  most  recently  matched
              token, the equivalent of <B>yytext.</B>

       <B>int</B> <B>YYLeng()</B>
              returns  the  length  of  the most recently matched
              token, the equivalent of <B>yyleng.</B>

       <B>int</B> <B>lineno()</B> <B>const</B>
              returns the current input line number (see  <B>%option</B>
              <B>yylineno),</B> or <B>1</B> if <B>%option</B> <B>yylineno</B> was not used.

       <B>void</B> <B>set_debug(</B> <B>int</B> <B>flag</B> <B>)</B>
              sets the debugging flag for the scanner, equivalent

       The  second  class  defined in <I>FlexLexer.h</I> is <B>yyFlexLexer,</B>
       which is derived from <B>FlexLexer.</B>  It defines the following
       additional member functions:

       <B>yyFlexLexer(</B> <B>istream*</B> <B>arg_yyin</B> <B>=</B> <B>0,</B> <B>ostream*</B> <B>arg_yyout</B> <B>=</B> <B>0</B>
       <B>)</B>
              constructs  a  <B>yyFlexLexer</B>  object  using the given
              streams for input and output.   If  not  specified,
              the  streams default to <B>cin</B> and <B>cout,</B> respectively.

       <B>virtual</B> <B>int</B> <B>yylex()</B>
              performs the same role is <B>yylex()</B> does for ordinary
              flex scanners: it scans the input stream, consuming
              tokens, until a rule's action returns a value.   If
              you  derive  a subclass <B>S</B> from <B>yyFlexLexer</B> and want
              to access the member functions and variables  of  <B>S</B>
              inside  <B>yylex(),</B>  then  you  need  to  use  <B>%option</B>
              <B>yyclass="S"</B> to inform <I>flex</I> that you will  be  using
              that  subclass  instead  of  <B>yyFlexLexer.</B>   In this
              case, rather than generating  <B>yyFlexLexer::yylex(),</B>
              <I>flex</I>  generates  <B>S::yylex()</B>  (and  also generates a
              dummy     <B>yyFlexLexer::yylex()</B>      that      calls
              <B>yyFlexLexer::LexerError()</B> if called).

       <B>virtual</B> <B>void</B> <B>switch_streams(istream*</B> <B>new_in</B> <B>=</B> <B>0,</B>
              <B>ostream*</B>  <B>new_out</B> <B>=</B> <B>0)</B> reassigns <B>yyin</B> to <B>new_in</B> (if
              non-nil) and <B>yyout</B> to <B>new_out</B> (ditto), deleting the
              previous input buffer if <B>yyin</B> is reassigned.

       <B>int</B> <B>yylex(</B> <B>istream*</B> <B>new_in,</B> <B>ostream*</B> <B>new_out</B> <B>=</B> <B>0</B> <B>)</B>
              first    switches    the    input    streams    via
              <B>switch_streams(</B> <B>new_in,</B> <B>new_out</B> <B>)</B> and then  returns
              the value of <B>yylex().</B>

       In  addition,  <B>yyFlexLexer</B> defines the following protected
       virtual  functions  which  you  can  redefine  in  derived
       classes to tailor the scanner:

       <B>virtual</B> <B>int</B> <B>LexerInput(</B> <B>char*</B> <B>buf,</B> <B>int</B> <B>max_size</B> <B>)</B>
              reads  up  to  <B>max_size</B>  characters  into  <B>buf</B>  and
              returns the number of characters read.  To indicate
              end-of-input,   return  0  characters.   Note  that
              "interactive" scanners (see the <B>-B</B>  and  <B>-I</B>  flags)
              define  the  macro <B>YY_INTERACTIVE.</B>  If you redefine
              <B>LexerInput()</B> and need  to  take  different  actions
              depending  on  whether  or not the scanner might be
              scanning an interactive input source, you can  test
              for the presence of this name via <B>#ifdef.</B>

       <B>virtual</B> <B>void</B> <B>LexerOutput(</B> <B>const</B> <B>char*</B> <B>buf,</B> <B>int</B> <B>size</B> <B>)</B>
              writes  out  <B>size</B>  characters  from the buffer <B>buf,</B>

       using the <B>-P</B> option discussed above.

       Finally,  note that the <B>%array</B> feature is not available to
       C++ scanner classes; you must use <B>%pointer</B> (the  default).

       Here is an example of a simple C++ scanner:

               // An example of using the flex C++ scanner class.

           %{
           int mylineno = 0;
           %}

           string  \"[^\n"]+\"

           ws      [ \t]+

           alpha   [A-Za-z]
           dig     [0-9]
           name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
           num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
           num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
           number  {num1}|{num2}

           %%

           {ws}    /* skip blanks and tabs */

           "/*"    {
                   int c;

                   while((c = yyinput()) != 0)
                       {
                       if(c == '\n')
                           ++mylineno;

                       else if(c == '*')
                           {
                           if((c = yyinput()) == '/')
                               break;
                           else
                               unput(c);
                           }
                       }
                   }

           {number}  cout &lt;&lt; "number " &lt;&lt; YYText() &lt;&lt; '\n';

           \n        mylineno++;

           {name}    cout &lt;&lt; "name " &lt;&lt; YYText() &lt;&lt; '\n';

       include <B>&lt;FlexLexer.h&gt;</B> in your other sources once per lexer
       class, first renaming <B>yyFlexLexer</B> as follows:

           #undef yyFlexLexer
           #define yyFlexLexer xxFlexLexer
           #include &lt;FlexLexer.h&gt;

           #undef yyFlexLexer
           #define yyFlexLexer zzFlexLexer
           #include &lt;FlexLexer.h&gt;

       if,  for  example, you used <B>%option</B> <B>prefix="xx"</B> for one of
       your scanners and <B>%option</B> <B>prefix="zz"</B> for the other.

       IMPORTANT: the present  form  of  the  scanning  class  is
       <I>experimental</I>  and  may  change  considerably between major
       releases.


</PRE>
<H2>INCOMPATIBILITIES WITH LEX AND POSIX</H2><PRE>
       <I>flex</I> is a rewrite of the  AT&amp;T  Unix  <I>lex</I>  tool  (the  two
       implementations  do not share any code, though), with some
       extensions and incompatibilities, both  of  which  are  of
       concern  to those who wish to write scanners acceptable to
       either implementation.  Flex is fully compliant  with  the
       POSIX  <I>lex</I>  specification, except that when using <B>%pointer</B>
       (the default), a call to <B>unput()</B> destroys the contents  of
       <B>yytext,</B> which is counter to the POSIX specification.

       In  this  section  we  discuss  all  of the known areas of
       incompatibility between flex,  AT&amp;T  lex,  and  the  POSIX
       specification.

       <I>flex's</I>  <B>-l</B>  option turns on maximum compatibility with the
       original AT&amp;T <I>lex</I> implementation, at the cost of  a  major
       loss  in  the  generated  scanner's  performance.  We note
       below which incompatibilities can be overcome using the <B>-l</B>
       option.

       <I>flex</I>  is  fully  compatible  with  <I>lex</I>  with the following
       exceptions:

       -      The  undocumented  <I>lex</I>  scanner  internal  variable
              <B>yylineno</B>  is  not  supported  unless  <B>-l</B> or <B>%option</B>
              <B>yylineno</B> is used.

              <B>yylineno</B>  should  be  maintained  on  a  per-buffer
              basis,  rather  than  a  per-scanner (single global
              variable) basis.

              <B>yylineno</B> is not part of the POSIX specification.

       -      The <B>input()</B> routine is not redefinable,  though  it

       -      The  <B>unput()</B>  routine  is  not  redefinable.   This
              restriction is in accordance with POSIX.

       -      <I>flex</I> scanners are not as reentrant as <I>lex</I> scanners.
              In particular, if you have an  interactive  scanner
              and  an  interrupt  handler which long-jumps out of
              the scanner, and the scanner is subsequently called
              again, you may get the following message:

                  fatal flex scanner internal error--end of buffer missed

              To reenter the scanner, first use

                  yyrestart( yyin );

              Note  that  this  call will throw away any buffered
              input; usually this isn't a problem with an  inter­
              active scanner.

              Also  note  that flex C++ scanner classes <I>are</I> reen­
              trant, so if using C++ is an option  for  you,  you
              should use them instead.  See "Generating C++ Scan­
              ners" above for details.

       -      <B>output()</B> is not supported.  Output  from  the  <B>ECHO</B>
              macro  is  done  to the file-pointer <I>yyout</I> (default
              <I>stdout).</I>

              <B>output()</B> is not part of the POSIX specification.

       -      <I>lex</I> does not  support  exclusive  start  conditions
              (%x), though they are in the POSIX specification.

       -      When  definitions  are expanded, <I>flex</I> encloses them
              in parentheses.  With lex, the following:

                  NAME    [A-Z][A-Z0-9]*
                  %%
                  foo{NAME}?      printf( "Found it\n" );
                  %%

              will not match the string "foo"  because  when  the
              macro is expanded the rule is equivalent to "foo[A-
              Z][A-Z0-9]*?"  and the precedence is such that  the
              '?' is associated with "[A-Z0-9]*".  With <I>flex,</I> the
              rule will be expanded to "foo([A-Z][A-Z0-9]*)?" and
              so the string "foo" will match.

              Note  that  if the definition begins with <B>^</B> or ends
              with <B>$</B> then it is <I>not</I> expanded with parentheses, to
              allow  these  operators  to  appear  in definitions
                  %%
                  foo|bar&lt;space here&gt;
                    { foobar_action(); }

              <I>flex</I> does not support this feature.

       -      The <I>lex</I> <B>%r</B> (generate a Ratfor  scanner)  option  is
              not  supported.  It is not part of the POSIX speci­
              fication.

       -      After a call to <B>unput(),</B> <I>yytext</I> is undefined  until
              the  next  token is matched, unless the scanner was
              built using <B>%array.</B>  This is not the case with  <I>lex</I>
              or  the  POSIX  specification.   The <B>-l</B> option does
              away with this incompatibility.

       -      The precedence of the <B>{}</B> (numeric  range)  operator
              is  different.  <I>lex</I> interprets "abc{1,3}" as "match
              one, two, or three occurrences of  'abc'",  whereas
              <I>flex</I>  interprets it as "match 'ab' followed by one,
              two, or three occurrences of 'c'".  The  latter  is
              in agreement with the POSIX specification.

       -      The precedence of the <B>^</B> operator is different.  <I>lex</I>
              interprets "^foo|bar" as "match either 'foo' at the
              beginning  of  a  line, or 'bar' anywhere", whereas
              <I>flex</I> interprets it as "match either 'foo' or  'bar'
              if they come at the beginning of a line".  The lat­
              ter is in agreement with the POSIX specification.

       -      The special table-size declarations such as <B>%a</B> sup­
              ported  by  <I>lex</I>  are not required by <I>flex</I> scanners;
              <I>flex</I> ignores them.

       -      The name FLEX_SCANNER is #define'd so scanners  may
              be  written for use with either <I>flex</I> or <I>lex.</I>  Scan­
              ners   also   include   <B>YY_FLEX_MAJOR_VERSION</B>   and
              <B>YY_FLEX_MINOR_VERSION</B>  indicating  which version of
              <I>flex</I> generated the scanner (for  example,  for  the
              2.5 release, these defines would be 2 and 5 respec­
              tively).

       The following <I>flex</I> features are not included in <I>lex</I> or the
       POSIX specification:

           C++ scanners
           %option
           start condition scopes
           start condition stacks
           interactive/non-interactive scanners
           yy_scan_string() and friends
           yyterminate()

       the list refers to the fact that with  <I>flex</I>  you  can  put
       multiple  actions  on  the same line, separated with semi-
       colons, while with <I>lex,</I> the following

           foo    handle_foo(); ++num_foos_seen;

       is (rather surprisingly) truncated to

           foo    handle_foo();

       <I>flex</I> does not truncate the action.  Actions that  are  not
       enclosed in braces are simply terminated at the end of the
       line.


</PRE>
<H2>DIAGNOSTICS</H2><PRE>
       <I>warning,</I> <I>rule</I> <I>cannot</I> <I>be</I> <I>matched</I> indicates that  the  given
       rule cannot be matched because it follows other rules that
       will always match the same text as it.   For  example,  in
       the  following  "foo"  cannot  be matched because it comes
       after an identifier "catch-all" rule:

           [a-z]+    got_identifier();
           foo       got_foo();

       Using <B>REJECT</B> in a scanner suppresses this warning.

       <I>warning,</I> <B>-s</B> <I>option</I> <I>given</I> <I>but</I> <I>default</I> <I>rule</I> <I>can</I>  <I>be</I>  <I>matched</I>
       means  that  it  is possible (perhaps only in a particular
       start condition) that the default rule (match  any  single
       character)  is  the  only one that will match a particular
       input.   Since  <B>-s</B>  was  given,  presumably  this  is  not
       intended.

       <I>reject</I><B>_</B><I>used</I><B>_</B><I>but</I><B>_</B><I>not</I><B>_</B><I>detected</I>          <I>undefined</I>         or
       <I>yymore</I><B>_</B><I>used</I><B>_</B><I>but</I><B>_</B><I>not</I><B>_</B><I>detected</I> <I>undefined</I> <I>-</I> These errors  can
       occur  at  compile  time.   They indicate that the scanner
       uses <B>REJECT</B> or <B>yymore()</B> but that <I>flex</I> failed to notice the
       fact,  meaning  that  <I>flex</I>  scanned the first two sections
       looking for occurrences of these  actions  and  failed  to
       find  any,  but  somehow you snuck some in (via a #include
       file, for example).  Use <B>%option</B> <B>reject</B> or <B>%option</B>  <B>yymore</B>
       to indicate to flex that you really do use these features.

       <I>flex</I> <I>scanner</I> <I>jammed</I> <I>-</I>  a  scanner  compiled  with  <B>-s</B>  has
       encountered an input string which wasn't matched by any of
       its rules.  This error can  also  occur  due  to  internal
       problems.

       <I>token</I> <I>too</I> <I>large,</I> <I>exceeds</I> <I>YYLMAX</I> <I>-</I> your scanner uses <B>%array</B>
       and one of its rules matched a string longer than the <B>YYL­</B>
       <B>MAX</B>  constant (8K bytes by default).  You can increase the
       value by #define'ing <B>YYLMAX</B> in the definitions section  of

       <I>input</I> <I>buffer</I> <I>overflow,</I> <I>can't</I> <I>enlarge</I> <I>buffer</I> <I>because</I>  <I>scan­</I>
       <I>ner</I>  <I>uses</I>  <I>REJECT</I> <I>-</I> the scanner was working on matching an
       extremely large token  and  needed  to  expand  the  input
       buffer.   This doesn't work with scanners that use <B>REJECT.</B>

       <I>fatal</I> <I>flex</I> <I>scanner</I> <I>internal</I> <I>error--end</I> <I>of</I> <I>buffer</I> <I>missed</I>  <I>-</I>
       This  can  occur  in an scanner which is reentered after a
       long-jump has jumped out (or over) the  scanner's  activa­
       tion frame.  Before reentering the scanner, use:

           yyrestart( yyin );

       or, as noted above, switch to using the C++ scanner class.

       <I>too</I> <I>many</I> <I>start</I> <I>conditions</I> <I>in</I> <I>&lt;&gt;</I> <I>construct!</I>  <I>-</I>  you  listed
       more start conditions in a &lt;&gt; construct than exist (so you
       must have listed at least one of them twice).


</PRE>
<H2>FILES</H2><PRE>
       <B>-lfl</B>   library with which scanners must be linked.

       <I>lex.yy.c</I>
              generated scanner (called <I>lexyy.c</I> on some systems).

       <I>lex.yy.cc</I>
              generated C++ scanner class, when using <B>-+.</B>

       <I>&lt;FlexLexer.h&gt;</I>
              header  file  defining  the C++ scanner base class,
              <B>FlexLexer,</B> and its derived class, <B>yyFlexLexer.</B>

       <I>flex.skl</I>
              skeleton scanner.  This  file  is  only  used  when
              building flex, not when flex executes.

       <I>lex.backup</I>
              backing-up  information for <B>-b</B> flag (called <I>lex.bck</I>
              on some systems).


</PRE>
<H2>DEFICIENCIES / BUGS</H2><PRE>
       Some trailing context patterns cannot be properly  matched
       and  generate  warning  messages ("dangerous trailing con­
       text").  These are patterns where the ending of the  first
       part of the rule matches the beginning of the second part,
       such as "zx*/xy*", where the 'x*' matches the 'x'  at  the
       beginning  of  the trailing context.  (Note that the POSIX
       draft states that the text matched  by  such  patterns  is
       undefined.)

       For  some trailing context rules, parts which are actually
       fixed-length are not recognized as such,  leading  to  the
       Use of <B>unput()</B> invalidates yytext and yyleng,  unless  the
       <B>%array</B> directive or the <B>-l</B> option has been used.

       Pattern-matching  of  NUL's  is  substantially slower than
       matching other characters.

       Dynamic resizing of  the  input  buffer  is  slow,  as  it
       entails rescanning all the text matched so far by the cur­
       rent (generally huge) token.

       Due to both buffering of input and read-ahead, you  cannot
       intermix  calls  to &lt;stdio.h&gt; routines, such as, for exam­
       ple, <B>getchar(),</B> with <I>flex</I> rules and  expect  it  to  work.
       Call <B>input()</B> instead.

       The total table entries listed by the <B>-v</B> flag excludes the
       number of table entries needed to determine what rule  has
       been  matched.  The number of entries is equal to the num­
       ber of DFA states if the scanner does not use <B>REJECT,</B>  and
       somewhat greater than the number of states if it does.

       <B>REJECT</B> cannot be used with the <B>-f</B> or <B>-F</B> options.

       The <I>flex</I> internal algorithms need documentation.


</PRE>
<H2>SEE ALSO</H2><PRE>
       <B>lex(1)</B>, <B>yacc(1)</B>, <B>sed(1)</B>, <B>awk(1)</B>.

       John  Levine,  Tony  Mason,  and  Doug  Brown, <I>Lex</I> <I>&amp;</I> <I>Yacc,</I>
       O'Reilly and Associates.  Be sure to get the 2nd  edition.

       M.  E. Lesk and E. Schmidt, <I>LEX</I> <I>-</I> <I>Lexical</I> <I>Analyzer</I> <I>Genera­</I>
       <I>tor</I>

       Alfred Aho, Ravi  Sethi  and  Jeffrey  Ullman,  <I>Compilers:</I>
       <I>Principles,</I>  <I>Techniques</I>  <I>and</I> <I>Tools,</I> Addison-Wesley (1986).
       Describes the pattern-matching  techniques  used  by  <I>flex</I>
       (deterministic finite automata).


</PRE>
<H2>AUTHOR</H2><PRE>
       Vern Paxson, with the help of many ideas and much inspira­
       tion  from  Van  Jacobson.   Original   version   by   Jef
       Poskanzer.   The  fast  table  representation is a partial
       implementation of a design  done  by  Van  Jacobson.   The
       implementation was done by Kevin Gong and Vern Paxson.

       Thanks  to  the  many  <I>flex</I> beta-testers, feedbackers, and
       contributors, especially Francois  Pinard,  Casey  Leedom,
       Robert  Abramovitz,  Stan  Adermann,  Terry  Allen,  David
       Barker-Plummer, John  Basrai,  Neal  Becker,  Nelson  H.F.
       Beebe,  benson@odi.com,  Karl Berry, Peter A. Bigot, Simon
       Blanchard, Keith Bostic, Frederic  Brehm,  Ian  Brockbank,
       Lenard, Craig Leres, John Levine, Steve Liddle, David Lof­
       fredo, Mike Long, Mohamed el Lozy,  Brian  Madsen,  Malte,
       Joe  Marshall,  Bengt Martensson, Chris Metcalf, Luke Mew­
       burn, Jim Meyering, R. Alexander  Milowski,  Erik  Naggum,
       G.T.  Nicol,  Landon  Noll,  James  Nordby,  Marc  Nozell,
       Richard Ohnemus, Karsten Pahnke, Sven Panne, Roland Pesch,
       Walter   Pelissero,   Gaumond  Pierre,  Esmond  Pitt,  Jef
       Poskanzer, Joe Rahmeh, Jarmo  Raiha,  Frederic  Raimbault,
       Pat  Rankin,  Rick Richardson, Kevin Rodgers, Kai Uwe Rom­
       mel, Jim Roskind, Alberto Santini, Andreas  Scherer,  Dar­
       rell Schiebel, Raf Schietekat, Doug Schmidt, Philippe Sch­
       noebelen, Andreas Schwab, Larry  Schwimmer,  Alex  Siegel,
       Eckehard Stolz, Jan-Erik Strvmquist, Mike Stump, Paul Stu­
       art,  Dave  Tallman,  Ian  Lance  Taylor,  Chris  Thewalt,
       Richard  M.  Timoney, Jodi Tsai, Paul Tuinenga, Gary Weik,
       Frank Whaley, Gerhard Wilhelms, Kent  Williams,  Ken  Yap,
       Ron  Zellar,  Nathan  Zelle,  David  Zuhn, and those whose
       names have slipped my marginal mail-archiving  skills  but
       whose contributions are appreciated all the same.

       Thanks  to  Keith Bostic, Jon Forrest, Noah Friedman, John
       Gilmore, Craig  Leres,  John  Levine,  Bob  Mulcahy,  G.T.
       Nicol,  Francois  Pinard,  Rich Salz, and Richard Stallman
       for help with various distribution headaches.

       Thanks to Esmond Pitt and Earle Horton for 8-bit character
       support;  to  Benson Margulies and Fred Burke for C++ sup­
       port; to Kent Williams and Tom Epperly for C++ class  sup­
       port;  to  Ove  Ewerlid  for support of NUL's; and to Eric
       Hughes for support of multiple buffers.

       This work was primarily done when I was with the Real Time
       Systems  Group  at  the  Lawrence  Berkeley  Laboratory in
       Berkeley, CA.  Many thanks to all there for the support  I
       received.

       Send comments to vern@ee.lbl.gov.



Version 2.5                 April 1995                    <B>FLEX(1)</B>
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
